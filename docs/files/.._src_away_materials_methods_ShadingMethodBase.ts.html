<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/away/materials/methods/ShadingMethodBase.ts</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/away.base.Geometry.html">away.base.Geometry</a></li>
            
                <li><a href="../classes/away.base.Object3D.html">away.base.Object3D</a></li>
            
                <li><a href="../classes/away.base.SkinnedSubGeometry.html">away.base.SkinnedSubGeometry</a></li>
            
                <li><a href="../classes/away.base.SubGeometry.html">away.base.SubGeometry</a></li>
            
                <li><a href="../classes/away.base.SubGeometryBase.html">away.base.SubGeometryBase</a></li>
            
                <li><a href="../classes/away.events.AssetEvent.html">away.events.AssetEvent</a></li>
            
                <li><a href="../classes/away.events.CameraEvent.html">away.events.CameraEvent</a></li>
            
                <li><a href="../classes/away.events.Event.html">away.events.Event</a></li>
            
                <li><a href="../classes/away.events.EventDispatcher.html">away.events.EventDispatcher</a></li>
            
                <li><a href="../classes/away.events.GeometryEvent.html">away.events.GeometryEvent</a></li>
            
                <li><a href="../classes/away.events.HTTPStatusEvent.html">away.events.HTTPStatusEvent</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/away.base.html">away.base</a></li>
            
                <li><a href="../modules/away.events.html">away.events</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../src/away/materials/methods/ShadingMethodBase.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
///&lt;reference path=&quot;../../_definitions.ts&quot;/&gt;

module away.materials
{
	//import away3d.*;
	//import away3d.cameras.*;
	//import away3d.core.base.*;
	//import away3d.managers.*;
	//import away3d.events.*;
	//import away3d.library.assets.*;
	//import away3d.materials.compilation.*;
	//import away3d.materials.passes.*;
	//import away3d.textures.*;
	
	//import flash.display3D.*;
	
	//use namespace arcane;
	
	/**
	 * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile
	 * the final shading program.
	 */
	export class ShadingMethodBase extends away.library.NamedAssetBase
	{
		public _sharedRegisters:away.materials.ShaderRegisterData; // should be protected
		private _passes:away.materials.MaterialPassBase[];//Vector.&lt;MaterialPassBase&gt;;
		
		/**
		 * Create a new ShadingMethodBase object.
		 * @param needsNormals Defines whether or not the method requires normals.
		 * @param needsView Defines whether or not the method requires the view direction.
		 */
		constructor() // needsNormals : boolean, needsView : boolean, needsGlobalPos : boolean
		{
            super();
		}

		/**
		 * Initializes the properties for a MethodVO, including register and texture indices.
		 * @param vo The MethodVO object linking this method with the pass currently being compiled.
		 */
		public iInitVO(vo:away.materials.MethodVO)
		{
		
		}

		/**
		 * Initializes unchanging shader constants using the data from a MethodVO.
		 * @param vo The MethodVO object linking this method with the pass currently being compiled.
		 */
		public iInitConstants(vo:away.materials.MethodVO)
		{



		}

		/**
		 * The shared registers created by the compiler and possibly used by methods.
		 */
		public get iSharedRegisters():away.materials.ShaderRegisterData
		{
			return this._sharedRegisters;
		}

        public set iSharedRegisters(value:away.materials.ShaderRegisterData)
        {
            this._sharedRegisters = value;
        }

        public setISharedRegisters(value:away.materials.ShaderRegisterData)
        {
            this._sharedRegisters = value;
        }
		
		/**
		 * Any passes required that render to a texture used by this method.
		 */
		public get passes():away.materials.MaterialPassBase[]//Vector.&lt;MaterialPassBase&gt;
		{
			return this._passes;
		}
		
		/**
		 * Cleans up any resources used by the current object.
		 */
		public dispose()
		{
		
		}
		
		/**
		 * Creates a data container that contains material-dependent data. Provided as a factory method so a custom subtype can be overridden when needed.
		 */
		public iCreateMethodVO():away.materials.MethodVO
		{
			return new away.materials.MethodVO();
		}

		/**
		 * Resets the compilation state of the method.
		 */
		public iReset()
		{
			this.iCleanCompilationData();
		}
		
		/**
		 * Resets the method&#x27;s state for compilation.
		 * @private
		 */
		public iCleanCompilationData()
		{
		}
		
		/**
		 * Get the vertex shader code for this method.
		 * @param vo The MethodVO object linking this method with the pass currently being compiled.
		 * @param regCache The register cache used during the compilation.
		 * @private
		 */
		public iGetVertexCode(vo:away.materials.MethodVO, regCache:away.materials.ShaderRegisterCache):string
		{
			return &quot;&quot;;
		}
		
		/**
		 * Sets the render state for this method.
		 *
		 * @param vo The MethodVO object linking this method with the pass currently being compiled.
		 * @param stage3DProxy The Stage3DProxy object currently used for rendering.
		 * @private
		 */
		public iActivate(vo:away.materials.MethodVO, stage3DProxy:away.managers.Stage3DProxy)
		{
		
		}
		
		/**
		 * Sets the render state for a single renderable.
		 *
		 * @param vo The MethodVO object linking this method with the pass currently being compiled.
		 * @param renderable The renderable currently being rendered.
		 * @param stage3DProxy The Stage3DProxy object currently used for rendering.
		 * @param camera The camera from which the scene is currently rendered.
		 */
		public iSetRenderState(vo:away.materials.MethodVO, renderable:away.base.IRenderable, stage3DProxy:away.managers.Stage3DProxy, camera:away.cameras.Camera3D)
		{
		
		}
		
		/**
		 * Clears the render state for this method.
		 * @param vo The MethodVO object linking this method with the pass currently being compiled.
		 * @param stage3DProxy The Stage3DProxy object currently used for rendering.
		 */
		public iDeactivate(vo:away.materials.MethodVO, stage3DProxy:away.managers.Stage3DProxy)
		{
		
		}
		
		/**
		 * A helper method that generates standard code for sampling from a texture using the normal uv coordinates.
		 * @param vo The MethodVO object linking this method with the pass currently being compiled.
		 * @param targetReg The register in which to store the sampled colour.
		 * @param inputReg The texture stream register.
		 * @param texture The texture which will be assigned to the given slot.
		 * @param uvReg An optional uv register if coordinates different from the primary uv coordinates are to be used.
		 * @param forceWrap If true, texture wrapping is enabled regardless of the material setting.
		 * @return The fragment code that performs the sampling.
		 */
		public pGetTex2DSampleCode(vo:away.materials.MethodVO, targetReg:away.materials.ShaderRegisterElement, inputReg:away.materials.ShaderRegisterElement, texture:away.textures.TextureProxyBase, uvReg:away.materials.ShaderRegisterElement = null, forceWrap:string = null):string
		{
			var wrap:string = forceWrap || (vo.repeatTextures? &quot;wrap&quot; : &quot;clamp&quot;);
			var filter:string;

			var format:string = this.getFormatStringForTexture(texture);
			var enableMipMaps:boolean = vo.useMipmapping &amp;&amp; texture.hasMipMaps;
			
			if (vo.useSmoothTextures)
				filter = enableMipMaps? &quot;linear,miplinear&quot; : &quot;linear&quot;;
			else
				filter = enableMipMaps? &quot;nearest,mipnearest&quot; : &quot;nearest&quot;;

            //uvReg ||= _sharedRegisters.uvVarying;
            if ( uvReg == null )
            {

                uvReg = this._sharedRegisters.uvVarying;

            }

			return &quot;tex &quot; + targetReg.toString() + &quot;, &quot; + uvReg.toString() + &quot;, &quot; + inputReg.toString() + &quot; &lt;2d,&quot; + filter + &quot;,&quot; + format + wrap + &quot;&gt;\n&quot;;

		}

		/**
		 * A helper method that generates standard code for sampling from a cube texture.
		 * @param vo The MethodVO object linking this method with the pass currently being compiled.
		 * @param targetReg The register in which to store the sampled colour.
		 * @param inputReg The texture stream register.
		 * @param texture The cube map which will be assigned to the given slot.
		 * @param uvReg The direction vector with which to sample the cube map.
		 */
		public pGetTexCubeSampleCode(vo:MethodVO, targetReg:away.materials.ShaderRegisterElement, inputReg:away.materials.ShaderRegisterElement, texture:away.textures.TextureProxyBase, uvReg:away.materials.ShaderRegisterElement):string
		{
			var filter:string;
			var format:string = this.getFormatStringForTexture(texture);
			var enableMipMaps:boolean = vo.useMipmapping &amp;&amp; texture.hasMipMaps;
			
			if (vo.useSmoothTextures)
				filter = enableMipMaps? &quot;linear,miplinear&quot; : &quot;linear&quot;;
			else
				filter = enableMipMaps? &quot;nearest,mipnearest&quot; : &quot;nearest&quot;;
			
			return &quot;tex &quot; + targetReg.toString() + &quot;, &quot; + uvReg.toString() + &quot;, &quot; + inputReg.toString() + &quot; &lt;cube,&quot; + format + filter + &quot;&gt;\n&quot;;
		}

		/**
		 * Generates a texture format string for the sample instruction.
		 * @param texture The texture for which to get the format string.
		 * @return
		 */
		private getFormatStringForTexture(texture:away.textures.TextureProxyBase):string
		{
			switch (texture.format) {
				case away.display3D.Context3DTextureFormat.COMPRESSED:
					return &quot;dxt1,&quot;;
					break;
				case &quot;compressedAlpha&quot;:
					return &quot;dxt5,&quot;;
					break;
				default:
					return &quot;&quot;;
			}
		}
		
		/**
		 * Marks the shader program as invalid, so it will be recompiled before the next render.
		 */
		public iInvalidateShaderProgram()
		{
			this.dispatchEvent(new away.events.ShadingMethodEvent(away.events.ShadingMethodEvent.SHADER_INVALIDATED));
		}
		
		/**
		 * Copies the state from a ShadingMethodBase object into the current object.
		 */
		public copyFrom(method:away.materials.ShadingMethodBase)
		{
		}
	}
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
