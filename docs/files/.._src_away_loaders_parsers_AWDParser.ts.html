<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/away/loaders/parsers/AWDParser.ts</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/away.base.Geometry.html">away.base.Geometry</a></li>
            
                <li><a href="../classes/away.base.Object3D.html">away.base.Object3D</a></li>
            
                <li><a href="../classes/away.base.SkinnedSubGeometry.html">away.base.SkinnedSubGeometry</a></li>
            
                <li><a href="../classes/away.base.SubGeometry.html">away.base.SubGeometry</a></li>
            
                <li><a href="../classes/away.base.SubGeometryBase.html">away.base.SubGeometryBase</a></li>
            
                <li><a href="../classes/away.events.AssetEvent.html">away.events.AssetEvent</a></li>
            
                <li><a href="../classes/away.events.CameraEvent.html">away.events.CameraEvent</a></li>
            
                <li><a href="../classes/away.events.Event.html">away.events.Event</a></li>
            
                <li><a href="../classes/away.events.EventDispatcher.html">away.events.EventDispatcher</a></li>
            
                <li><a href="../classes/away.events.GeometryEvent.html">away.events.GeometryEvent</a></li>
            
                <li><a href="../classes/away.events.HTTPStatusEvent.html">away.events.HTTPStatusEvent</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/away.base.html">away.base</a></li>
            
                <li><a href="../modules/away.events.html">away.events</a></li>
            
                <li><a href="../modules/away.geom.html">away.geom</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../src/away/loaders/parsers/AWDParser.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
///&lt;reference path=&quot;../../_definitions.ts&quot;/&gt;

module away.loaders
{

	/**
	 * AWDParser provides a parser for the AWD data type.
	 */
	export class AWDParser extends away.loaders.ParserBase
	{
		//set to &quot;true&quot; to have some traces in the Console
		private _debug                  : boolean = true;
		private _byteData               : away.utils.ByteArray;
		private _startedParsing         : boolean = false;
		private _cur_block_id           : number;
		private _blocks                 : Array&lt;AWDBlock&gt;;
		private _newBlockBytes          : away.utils.ByteArray;
		private _version                : Array&lt;number&gt;;
		private _compression            : number;
		private _accuracyOnBlocks       : boolean;
		private _accuracyMatrix         : boolean;
		private _accuracyGeo            : boolean;
		private _accuracyProps          : boolean;
		private _matrixNrType           : number;
		private _geoNrType              : number;
		private _propsNrType            : number;
		private _streaming              : boolean;
		private _texture_users          : Object = {};
		private _parsed_header          : boolean = false;
		private _body                   : away.utils.ByteArray;
		private _defaultTexture         : away.textures.BitmapTexture;     // HTML IMAGE TEXTURE &gt;? !
		private _cubeTextures           : Array&lt;any&gt;;
		private _defaultBitmapMaterial  : away.materials.TextureMaterial;
		private _defaultCubeTexture     : away.textures.BitmapCubeTexture;

		public static COMPRESSIONMODE_LZMA  : string = &quot;lzma&quot;;
		public static UNCOMPRESSED          : number = 0;
		public static DEFLATE               : number = 1;
		public static LZMA                  : number = 2;
		public static INT8                  : number = 1;
		public static INT16                 : number = 2;
		public static INT32                 : number = 3;
		public static UINT8                 : number = 4;
		public static UINT16                : number = 5;
		public static UINT32                : number = 6;
		public static FLOAT32               : number = 7;
		public static FLOAT64               : number = 8;
		public static BOOL                  : number = 21;
		public static COLOR                 : number = 22;
		public static BADDR                 : number = 23;
		public static AWDSTRING             : number = 31;
		public static AWDBYTEARRAY          : number = 32;
		public static VECTOR2x1             : number = 41;
		public static VECTOR3x1             : number = 42;
		public static VECTOR4x1             : number = 43;
		public static MTX3x2                : number = 44;
		public static MTX3x3                : number = 45;
		public static MTX4x3                : number = 46;
		public static MTX4x4                : number = 47;

		private blendModeDic                : Array&lt;string&gt;;
		private _depthSizeDic               : Array&lt;number&gt;;
		
		/**
		 * Creates a new AWDParser object.
		 * @param uri The url or id of the data or file to be parsed.
		 * @param extra The holder for extra contextual data that the parser might need.
		 */
		constructor()
		{
			super( away.loaders.ParserDataFormat.BINARY );
			
			this._blocks = new Array&lt;AWDBlock&gt;();
            this._blocks[0] = new AWDBlock();
            this._blocks[0].data = null; // Zero address means null in AWD
			
			this.blendModeDic = new Array&lt;string&gt;(); // used to translate ints to blendMode-strings
            this.blendModeDic.push(away.display.BlendMode.NORMAL);
            this.blendModeDic.push(away.display.BlendMode.ADD);
            this.blendModeDic.push(away.display.BlendMode.ALPHA);
            this.blendModeDic.push(away.display.BlendMode.DARKEN);
            this.blendModeDic.push(away.display.BlendMode.DIFFERENCE);
            this.blendModeDic.push(away.display.BlendMode.ERASE);
            this.blendModeDic.push(away.display.BlendMode.HARDLIGHT);
            this.blendModeDic.push(away.display.BlendMode.INVERT);
            this.blendModeDic.push(away.display.BlendMode.LAYER);
            this.blendModeDic.push(away.display.BlendMode.LIGHTEN);
            this.blendModeDic.push(away.display.BlendMode.MULTIPLY);
            this.blendModeDic.push(away.display.BlendMode.NORMAL);
            this.blendModeDic.push(away.display.BlendMode.OVERLAY);
            this.blendModeDic.push(away.display.BlendMode.SCREEN);
            this.blendModeDic.push(away.display.BlendMode.SHADER);
            this.blendModeDic.push(away.display.BlendMode.OVERLAY);
			
			this._depthSizeDic = new Array&lt;number&gt;(); // used to translate ints to depthSize-values
            this._depthSizeDic.push(256);
            this._depthSizeDic.push(512);
            this._depthSizeDic.push(2048);
            this._depthSizeDic.push(1024);
            this._version = Array&lt;number&gt;();//[]; // will contain 2 int (major-version, minor-version) for awd-version-check
		}
		
		/**
		 * Indicates whether or not a given file extension is supported by the parser.
		 * @param extension The file extension of a potential file to be parsed.
		 * @return Whether or not the given file type is supported.
		 */
		public static supportsType(extension:string):boolean
		{
			extension = extension.toLowerCase();
			return extension == &quot;awd&quot;;
		}
		
		/**
		 * Tests whether a data block can be parsed by the parser.
		 * @param data The data block to potentially be parsed.
		 * @return Whether or not the given data is supported.
		 */
		public static supportsData(data:any):boolean
		{
			return (away.loaders.ParserUtil.toString(data, 3) == &#x27;AWD&#x27;);
		}

        /**
         * @inheritDoc
         */
        public _iResolveDependency(resourceDependency:away.loaders.ResourceDependency):void
        {
            // this function will be called when Dependency has finished loading.
            // the Assets waiting for this Bitmap, can be Texture or CubeTexture.
            // if the Bitmap is awaited by a CubeTexture, we need to check if its the last Bitmap of the CubeTexture,
            // so we know if we have to finalize the Asset (CubeTexture) or not.
            if (resourceDependency.assets.length == 1)
            {
                var isCubeTextureArray  : Array&lt;string&gt; = resourceDependency.id.split(&quot;#&quot;);
                var ressourceID         : string = isCubeTextureArray[0];
                var asset               : away.textures.TextureProxyBase;
                var thisBitmapTexture   : away.textures.Texture2DBase;
                var block               : AWDBlock;

                if (isCubeTextureArray.length == 1) // Not a cube texture
                {
                    asset = &lt;away.textures.Texture2DBase&gt; resourceDependency.assets[0] ;
                    if (asset)
                    {
                        var mat     : away.materials.TextureMaterial;
                        var users   : Array;

                        block       = this._blocks[ resourceDependency.id ];
                        block.data  = asset; // Store finished asset

                        // Reset name of texture to the one defined in the AWD file,
                        // as opposed to whatever the image parser came up with.
                        asset.resetAssetPath(block.name, null, true);
                        block.name = asset.name;
                        // Finalize texture asset to dispatch texture event, which was
                        // previously suppressed while the dependency was loaded.
                        this._pFinalizeAsset( &lt;away.library.IAsset&gt; asset );

                        if (this._debug)
                        {
                            console.log(&quot;Successfully loaded Bitmap for texture&quot;);
                            console.log(&quot;Parsed texture: Name = &quot; + block.name);
                        }
                    }
                }

                if (isCubeTextureArray.length &gt; 1) // Cube Texture
                {
                    thisBitmapTexture = &lt;away.textures.BitmapTexture&gt; resourceDependency.assets[0] ;

                    var tx : away.textures.HTMLImageElementTexture = &lt;away.textures.HTMLImageElementTexture&gt; thisBitmapTexture;

                    this._cubeTextures[ isCubeTextureArray[1] ] = tx.htmlImageElement; // ?
                    this._texture_users[ressourceID].push(1);

                    if (this._debug)
                    {
                        console.log(&quot;Successfully loaded Bitmap &quot; + this._texture_users[ressourceID].length + &quot; / 6 for Cubetexture&quot;);
                    }
                    if (this._texture_users[ressourceID].length == this._cubeTextures.length)
                    {

                        var posX : any = this._cubeTextures[0];
                        var negX : any = this._cubeTextures[1];
                        var posY : any = this._cubeTextures[2];
                        var negY : any = this._cubeTextures[3];
                        var posZ : any = this._cubeTextures[4];
                        var negZ : any = this._cubeTextures[5];

                        asset       = new away.textures.HTMLImageElementCubeTexture( posX , negX , posY , negY , posZ , negZ ) ;
                        block       = this._blocks[ressourceID];
                        block.data  = asset; // Store finished asset

                        // Reset name of texture to the one defined in the AWD file,
                        // as opposed to whatever the image parser came up with.
                        asset.resetAssetPath(block.name, null, true);
                        block.name = asset.name;
                        // Finalize texture asset to dispatch texture event, which was
                        // previously suppressed while the dependency was loaded.
                        this._pFinalizeAsset(  &lt;away.library.IAsset&gt; asset );
                        if (this._debug)
                        {
                            console.log(&quot;Parsed CubeTexture: Name = &quot; + block.name);
                        }
                    }
                }

            }
        }

        /**
         * @inheritDoc
         */
        public _iResolveDependencyFailure(resourceDependency:away.loaders.ResourceDependency):void
        {
            //not used - if a dependcy fails, the awaiting Texture or CubeTexture will never be finalized, and the default-bitmaps will be used.
            // this means, that if one Bitmap of a CubeTexture fails, the CubeTexture will have the DefaultTexture applied for all six Bitmaps.
        }

        /**
         * Resolve a dependency name
         *
         * @param resourceDependency The dependency to be resolved.
         */
        public _iResolveDependencyName(resourceDependency:away.loaders.ResourceDependency, asset:away.library.IAsset):string
        {
            var oldName:string = asset.name;

            if (asset)
            {
                var block:AWDBlock = this._blocks[parseInt(resourceDependency.id)];
                // Reset name of texture to the one defined in the AWD file,
                // as opposed to whatever the image parser came up with.
                asset.resetAssetPath(block.name, null, true);
            }

            var newName:string = asset.name;

            asset.name = oldName;

            return newName;

        }

        /**
         * @inheritDoc
         */
        public _pProceedParsing():boolean
        {

            if ( ! this._startedParsing )
            {
                this._byteData = this._pGetByteData();//getByteData();
                this._startedParsing = true;
            }

            if ( ! this._parsed_header )
            {

                //----------------------------------------------------------------------------
                // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                //----------------------------------------------------------------------------
                //this._byteData.endian = Endian.LITTLE_ENDIAN;
                //----------------------------------------------------------------------------

                //----------------------------------------------------------------------------
                // Parse header and decompress body if needed
                this.parseHeader();

                switch (this._compression)
                {

                    case AWDParser.DEFLATE:
                    case AWDParser.LZMA:
                            this._pDieWithError( &#x27;Compressed AWD formats not yet supported&#x27;);
                            break;

                    case AWDParser.UNCOMPRESSED:
                        this._body = this._byteData;
                        break;

                    //----------------------------------------------------------------------------
                    // Compressed AWD Formats not yet supported
                    //----------------------------------------------------------------------------

                    /*
                    case AWDParser.DEFLATE:

                        this._body = new away.utils.ByteArray();
                        this._byteData.readBytes(this._body, 0, this._byteData.getBytesAvailable());
                        this._body.uncompress();

                        break;
                    case AWDParser.LZMA:

                        this._body = new away.utils.ByteArray();
                        this._byteData.readBytes(this._body, 0, this._byteData.getBytesAvailable());
                        this._body.uncompress(COMPRESSIONMODE_LZMA);

                        break;
                    //*/

                }

                this._parsed_header = true;

                //----------------------------------------------------------------------------
                // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                //----------------------------------------------------------------------------
                //this._body.endian = Endian.LITTLE_ENDIAN;// Should be default
                //----------------------------------------------------------------------------

            }

            if ( this._body )
            {

                while (this._body.getBytesAvailable() &gt; 0 &amp;&amp; ! this.parsingPaused ) //&amp;&amp; this._pHasTime() )
                {
                    this.parseNextBlock();

                }

                //----------------------------------------------------------------------------
                // Return complete status
                if (this._body.getBytesAvailable() == 0)
                {
                    this.dispose();
                    return  away.loaders.ParserBase.PARSING_DONE;
                }
                else
                {
                    return  away.loaders.ParserBase.MORE_TO_PARSE;
                }
            }
            else
            {

                switch (this._compression)
                {

                    case AWDParser.DEFLATE:
                    case AWDParser.LZMA:

                        if ( this._debug )
                        {
                            console.log(&quot;(!) AWDParser Error: Compressed AWD formats not yet supported (!)&quot;);
                        }

                        break;

                }
                                // Error - most likely _body not set because we do not support compression.
                return  away.loaders.ParserBase.PARSING_DONE;

            }

        }

        private dispose() : void
        {

            for ( var c in this._blocks)
            {

                var b : AWDBlock = &lt;AWDBlock&gt; this._blocks[ c ];
                    b.dispose();

            }

        }

        private parseNextBlock():void
        {
            var block       : AWDBlock;
            var assetData   : away.library.IAsset;
            var isParsed    : boolean = false;
            var ns          : number;
            var type        : number;
            var flags       : number;
            var len         : number;

            this._cur_block_id = this._body.readUnsignedInt();

            ns      = this._body.readUnsignedByte();
            type    = this._body.readUnsignedByte();
            flags   = this._body.readUnsignedByte();
            len     = this._body.readUnsignedInt();

            var blockCompression        :boolean        = bitFlags.test(flags, bitFlags.FLAG4);
            var blockCompressionLZMA    :boolean        = bitFlags.test(flags, bitFlags.FLAG5);

            if (this._accuracyOnBlocks)
            {
                this._accuracyMatrix        = bitFlags.test(flags, bitFlags.FLAG1);
                this._accuracyGeo           = bitFlags.test(flags, bitFlags.FLAG2);
                this._accuracyProps         = bitFlags.test(flags, bitFlags.FLAG3);
                this._geoNrType             = AWDParser.FLOAT32;

                if (this._accuracyGeo)
                {
                    this._geoNrType     = AWDParser.FLOAT64;
                }

                this._matrixNrType      = AWDParser.FLOAT32;

                if (this._accuracyMatrix)
                {
                    this._matrixNrType  = AWDParser.FLOAT64;
                }

                this._propsNrType       = AWDParser.FLOAT32;

                if (this._accuracyProps)
                {
                    this._propsNrType   = AWDParser.FLOAT64;
                }
            }

            var blockEndAll:number = this._body.position + len;

            if (len &gt; this._body.getBytesAvailable() )
            {
                this._pDieWithError(&#x27;AWD2 block length is bigger than the bytes that are available!&#x27;);
                this._body.position += this._body.getBytesAvailable();
                return;
            }
            this._newBlockBytes = new away.utils.ByteArray();


            this._body.readBytes(this._newBlockBytes, 0, len);

            //----------------------------------------------------------------------------
            // Compressed AWD Formats not yet supported

            if ( blockCompression )
            {
                this._pDieWithError( &#x27;Compressed AWD formats not yet supported&#x27;);

                /*
                 if (blockCompressionLZMA)
                 {
                 this._newBlockBytes.uncompress(AWDParser.COMPRESSIONMODE_LZMA);
                 }
                 else
                 {
                 this._newBlockBytes.uncompress();
                 }
                 */

            }

            //----------------------------------------------------------------------------
            // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
            //----------------------------------------------------------------------------
            //this._newBlockBytes.endian = Endian.LITTLE_ENDIAN;
            //----------------------------------------------------------------------------

            this._newBlockBytes.position = 0;
            block       = new AWDBlock();
            block.len   = this._newBlockBytes.position + len;
            block.id    = this._cur_block_id;

            var blockEndBlock : number = this._newBlockBytes.position + len;

            if (blockCompression)
            {
                this._pDieWithError( &#x27;Compressed AWD formats not yet supported&#x27;);
                //blockEndBlock   = this._newBlockBytes.position + this._newBlockBytes.length;
                //block.len       = blockEndBlock;
            }

            if (this._debug)
            {
                console.log(&quot;AWDBlock:  ID = &quot; + this._cur_block_id + &quot; | TypeID = &quot; + type + &quot; | Compression = &quot; + blockCompression + &quot; | Matrix-Precision = &quot; + this._accuracyMatrix + &quot; | Geometry-Precision = &quot; + this._accuracyGeo + &quot; | Properties-Precision = &quot; + this._accuracyProps);
            }

            this._blocks[this._cur_block_id] = block;

            if ((this._version[0] == 2) &amp;&amp; (this._version[1] == 1))
            {

                 switch (type)
                 {
                     case 11:
                         this.parsePrimitves(this._cur_block_id);
                         isParsed = true;
                         break;
                     case 31:
                         //this.parseSkyBoxInstance(this._cur_block_id);
                         //isParsed = true;
                         break;
                     case 41:
                         this.parseLight(this._cur_block_id);
                         isParsed = true;
                         break;
                     case 42:
                         this.parseCamera(this._cur_block_id);
                         isParsed = true;
                         break;

                     //  case 43:
                     //      parseTextureProjector(_cur_block_id);
                     //      isParsed = true;
                     //      break;

                     case 51:
                         this.parseLightPicker(this._cur_block_id);
                         isParsed = true;
                         break;
                     case 81:
                         this.parseMaterial_v1(this._cur_block_id);
                         isParsed = true;
                         break;
                     case 83:
                         this.parseCubeTexture(this._cur_block_id);
                         isParsed = true;
                         break;
                     case 91:
                         this.parseSharedMethodBlock(this._cur_block_id);
                         isParsed = true;
                         break;
                     case 92:
                         this.parseShadowMethodBlock(this._cur_block_id);
                         isParsed = true;
                         break;
                     case 111:

                         //------------------------------------------------------------------
                         // Not yet supported - animation packages are not yet implemented
                         //------------------------------------------------------------------

                         //this.parseMeshPoseAnimation(this._cur_block_id, true);
                         //isParsed = true;
                         break;
                     case 112:

                         //------------------------------------------------------------------
                         // Not yet supported - animation packages are not yet implemented
                         //------------------------------------------------------------------

                         //this.parseMeshPoseAnimation(this._cur_block_id);
                         //isParsed = true;
                         break;
                     case 113:

                         //------------------------------------------------------------------
                         // Not yet supported - animation packages are not yet implemented
                         //------------------------------------------------------------------

                         //this.parseVertexAnimationSet(this._cur_block_id);
                         //isParsed = true;
                         break;
                     case 122:

                         //------------------------------------------------------------------
                         // Not yet supported - animation packages are not yet implemented
                         //------------------------------------------------------------------

                         //this.parseAnimatorSet(this._cur_block_id);
                         //isParsed = true;
                         break;
                     case 253:
                         this.parseCommand(this._cur_block_id);
                         isParsed = true;
                         break;
                 }
                 //*/
            }
            //*
            if (isParsed == false)
            {
                switch (type)
                {

                    case 1:
                        this.parseTriangleGeometrieBlock(this._cur_block_id);
                        break;
                    case 22:
                        this.parseContainer(this._cur_block_id);
                        break;
                    case 23:
                        this.parseMeshInstance(this._cur_block_id);
                        break;
                    case 81:
                        this.parseMaterial(this._cur_block_id);
                        break;
                    case 82:
                        this.parseTexture(this._cur_block_id);
                        break;
                    case 101:

                        //------------------------------------------------------------------
                        // Not yet supported - animation packages are not yet implemented
                        //------------------------------------------------------------------

                        //this.parseSkeleton(this._cur_block_id);

                        break;
                    case 102:

                        //------------------------------------------------------------------
                        // Not yet supported - animation packages are not yet implemented
                        //------------------------------------------------------------------

                        //this.parseSkeletonPose(this._cur_block_id);
                        break;
                    case 103:

                        //------------------------------------------------------------------
                        // Not yet supported - animation packages are not yet implemented
                        //------------------------------------------------------------------

                        //this.parseSkeletonAnimation(this._cur_block_id);
                        break;
                    case 121:

                        //------------------------------------------------------------------
                        // Not yet supported - animation packages are not yet implemented
                        //------------------------------------------------------------------

                        //this.parseUVAnimation(this._cur_block_id);
                        break;
                    case 254:
                        this.parseNameSpace(this._cur_block_id);
                        break;
                    case 255:
                        this.parseMetaData(this._cur_block_id);
                        break;
                    default:
                        if (this._debug)
                        {
                            console.log(&quot;AWDBlock:   Unknown BlockType  (BlockID = &quot; + this._cur_block_id + &quot;) - Skip &quot; + len + &quot; bytes&quot;);
                        }
                        this._newBlockBytes.position += len;
                        break;
                }
            }
            //*/

            var msgCnt:number = 0;
            if (this._newBlockBytes.position == blockEndBlock)
            {
                if (this._debug)
                {
                    if (block.errorMessages)
                    {
                        while (msgCnt &lt; block.errorMessages.length)
                        {
                            console.log(&quot;        (!) Error: &quot; + block.errorMessages[msgCnt] + &quot; (!)&quot;);
                            msgCnt++;
                        }
                    }
                }
                if (this._debug)
                {
                    console.log(&quot;\n&quot;);
                }
            }
            else
            {
                if (this._debug)
                {

                    console.log(&quot;  (!)(!)(!) Error while reading AWDBlock ID &quot; + this._cur_block_id + &quot; = skip to next block&quot;);

                    if (block.errorMessages)
                    {
                        while (msgCnt &lt; block.errorMessages.length)
                        {
                            console.log(&quot;        (!) Error: &quot; + block.errorMessages[msgCnt] + &quot; (!)&quot;);
                            msgCnt++;
                        }
                    }
                }
            }

            this._body.position = blockEndAll;
            this._newBlockBytes = null;

        }


        //--Parser Blocks---------------------------------------------------------------------------

        //Block ID = 1
        private parseTriangleGeometrieBlock(blockID:number):void
        {

            var geom:away.base.Geometry = new away.base.Geometry();

            // Read name and sub count
            var name:string = this.parseVarStr();
            var num_subs:number = this._newBlockBytes.readUnsignedShort();

            // Read optional properties
            var props:AWDProperties = this.parseProperties({1:this._geoNrType, 2:this._geoNrType});
            var geoScaleU:number = props.get(1, 1);
            var geoScaleV:number = props.get(2, 1);

            // Loop through sub meshes
            var subs_parsed:number = 0;
            while (subs_parsed &lt; num_subs)
            {
                var i:number;
                var sm_len:number, sm_end:number;
                var sub_geoms:Array&lt;away.base.ISubGeometry&gt;;
                var w_indices:Array&lt;number&gt;;
                var weights:Array&lt;number&gt;;

                sm_len = this._newBlockBytes.readUnsignedInt();
                sm_end = this._newBlockBytes.position + sm_len;

                // Ignore for now
                var subProps:AWDProperties = this.parseProperties({1:this._geoNrType, 2:this._geoNrType});
                // Loop through data streams
                while (this._newBlockBytes.position &lt; sm_end) {
                    var idx:number= 0;
                    var str_ftype:number, str_type:number, str_len:number, str_end:number;

                    // Type, field type, length
                    str_type = this._newBlockBytes.readUnsignedByte();
                    str_ftype = this._newBlockBytes.readUnsignedByte();
                    str_len = this._newBlockBytes.readUnsignedInt();
                    str_end = this._newBlockBytes.position + str_len;

                    var x:number, y:number, z:number;

                    if (str_type == 1)
                    {
                        var verts:Array&lt;number&gt; = new Array&lt;number&gt;();

                        while (this._newBlockBytes.position &lt; str_end)
                        {
                            // TODO: Respect stream field type
                            x = this.readNumber(this._accuracyGeo);
                            y = this.readNumber(this._accuracyGeo);
                            z = this.readNumber(this._accuracyGeo);

                            verts[idx++] = x;
                            verts[idx++] = y;
                            verts[idx++] = z;
                        }
                    }
                    else if (str_type == 2)
                    {
                        var indices:Array&lt;number&gt; = new Array&lt;number&gt;();

                        while (this._newBlockBytes.position &lt; str_end)
                        {
                            // TODO: Respect stream field type
                            indices[idx++] = this._newBlockBytes.readUnsignedShort();
                        }

                    }
                    else if (str_type == 3)
                    {
                        var uvs:Array&lt;number&gt; = new Array&lt;number&gt;();
                        while (this._newBlockBytes.position &lt; str_end)
                        {
                            uvs[idx++] = this.readNumber(this._accuracyGeo);

                        }
                    }
                    else if (str_type == 4)
                    {

                        var normals:Array&lt;number&gt; = new Array&lt;number&gt;();

                        while (this._newBlockBytes.position &lt; str_end)
                        {
                            normals[idx++] = this.readNumber(this._accuracyGeo);
                        }

                    }
                    else if (str_type == 6)
                    {
                        w_indices = Array&lt;number&gt;();

                        while (this._newBlockBytes.position &lt; str_end)
                        {
                            w_indices[idx++] = this._newBlockBytes.readUnsignedShort()*3; // TODO: Respect stream field type
                        }

                    }
                    else if (str_type == 7)
                    {

                        weights = new Array&lt;number&gt;();

                        while (this._newBlockBytes.position &lt; str_end)
                        {
                            weights[idx++] = this.readNumber(this._accuracyGeo);
                        }
                    }
                    else
                    {
                        this._newBlockBytes.position = str_end;
                    }

                }

                this.parseUserAttributes(); // Ignore sub-mesh attributes for now

                sub_geoms = away.utils.GeometryUtils.fromVectors(verts, indices, uvs, normals, null, weights, w_indices);

                var scaleU:number = subProps.get(1, 1);
                var scaleV:number = subProps.get(2, 1);
                var setSubUVs:boolean = false; //this should remain false atm, because in AwayBuilder the uv is only scaled by the geometry

                if ((geoScaleU != scaleU) || (geoScaleV != scaleV))
                {
                    setSubUVs = true;
                    scaleU = geoScaleU/scaleU;
                    scaleV = geoScaleV/scaleV;
                }

                for (i = 0; i &lt; sub_geoms.length; i++) {
                    if (setSubUVs)
                        sub_geoms[i].scaleUV(scaleU, scaleV);
                    geom.addSubGeometry(sub_geoms[i]);
                    // TODO: Somehow map in-sub to out-sub indices to enable look-up
                    // when creating meshes (and their material assignments.)
                }
                subs_parsed++;
            }
            if ((geoScaleU != 1) || (geoScaleV != 1))
                geom.scaleUV(geoScaleU, geoScaleV);
            this.parseUserAttributes();
            this._pFinalizeAsset( &lt;away.library.IAsset&gt; geom, name);
            this._blocks[blockID].data = geom;

            if (this._debug)
            {
                console.log(&quot;Parsed a TriangleGeometry: Name = &quot; + name + &quot;| SubGeometries = &quot; + sub_geoms.length);
            }

        }

        //Block ID = 11
        private parsePrimitves(blockID:number):void
        {
            var name        : string;
            var geom        : away.base.Geometry;
            var primType    : number;
            var subs_parsed : number;
            var props       : AWDProperties;
            var bsm         : away.geom.Matrix3D;

            // Read name and sub count
            name        = this.parseVarStr();
            primType    = this._newBlockBytes.readUnsignedByte();
            props       = this.parseProperties({101:this._geoNrType, 102:this._geoNrType, 103:this._geoNrType, 110:this._geoNrType, 111:this._geoNrType, 301:AWDParser.UINT16, 302:AWDParser.UINT16, 303:AWDParser.UINT16, 701:AWDParser.BOOL, 702:AWDParser.BOOL, 703:AWDParser.BOOL, 704:AWDParser.BOOL});

            var primitveTypes:Array&lt;string&gt; = [&quot;Unsupported Type-ID&quot;, &quot;PlaneGeometry&quot;, &quot;CubeGeometry&quot;, &quot;SphereGeometry&quot;, &quot;CylinderGeometry&quot;, &quot;ConeGeometry&quot;, &quot;CapsuleGeometry&quot;, &quot;TorusGeometry&quot;]

            switch (primType)
            {
                // to do, not all properties are set on all primitives

                case 1:
                    geom = new away.primitives.PlaneGeometry(props.get(101, 100), props.get(102, 100), props.get(301, 1), props.get(302, 1), props.get(701, true), props.get(702, false));
                    break;

                case 2:
                    geom = new away.primitives.CubeGeometry(props.get(101, 100), props.get(102, 100), props.get(103, 100), props.get(301, 1), props.get(302, 1), props.get(303, 1), props.get(701, true));
                    break;

                case 3:
                    geom = new away.primitives.SphereGeometry(props.get(101, 50), props.get(301, 16), props.get(302, 12), props.get(701, true));
                    break;

                case 4:
                    geom = new away.primitives.CylinderGeometry(props.get(101, 50), props.get(102, 50), props.get(103, 100), props.get(301, 16), props.get(302, 1), true, true, true); // bool701, bool702, bool703, bool704);
                    if (!props.get(701, true))
                        (&lt;away.primitives.CylinderGeometry&gt;geom).topClosed = false;
                    if (!props.get(702, true))
                        (&lt;away.primitives.CylinderGeometry&gt;geom).bottomClosed = false;
                    if (!props.get(703, true))
                        (&lt;away.primitives.CylinderGeometry&gt;geom).yUp = false;

                    break;

                case 5:
                    geom = new away.primitives.ConeGeometry(props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 1), props.get(701, true), props.get(702, true));
                    break;

                case 6:
                    geom = new away.primitives.CapsuleGeometry(props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 15), props.get(701, true));
                    break;

                case 7:
                    geom = new away.primitives.TorusGeometry(props.get(101, 50), props.get(102, 50), props.get(301, 16), props.get(302, 8), props.get(701, true));
                    break;

                default:
                    geom = new away.base.Geometry();
                    console.log(&quot;ERROR: UNSUPPORTED PRIMITIVE_TYPE&quot;);
                    break;
            }

            if ((props.get(110, 1) != 1) || (props.get(111, 1) != 1))
            {
                geom.subGeometries;
                geom.scaleUV(props.get(110, 1), props.get(111, 1));
            }

            this.parseUserAttributes();
            geom.name = name;
            this._pFinalizeAsset(geom, name);
            this._blocks[blockID].data = geom;

            if (this._debug)
            {
                if ((primType &lt; 0) || (primType &gt; 7))
                {
                    primType = 0;
                }
                console.log(&quot;Parsed a Primivite: Name = &quot; + name + &quot;| type = &quot; + primitveTypes[primType]);
            }
        }

        // Block ID = 22
        private parseContainer(blockID:number):void
        {
            var name    : string;
            var par_id  : number;
            var mtx     : away.geom.Matrix3D;
            var ctr     : away.containers.ObjectContainer3D;
            var parent  : away.containers.ObjectContainer3D;

            par_id  = this._newBlockBytes.readUnsignedInt();
            mtx     = this.parseMatrix3D();
            name    = this.parseVarStr();

            var parentName:string   = &quot;Root (TopLevel)&quot;;
            ctr                     = new away.containers.ObjectContainer3D();
            ctr.transform           = mtx;

            var returnedArray:Array&lt;any&gt; = this.getAssetByID(par_id, [away.library.AssetType.CONTAINER, away.library.AssetType.LIGHT, away.library.AssetType.MESH, away.library.AssetType.ENTITY, away.library.AssetType.SEGMENT_SET]);

            if (returnedArray[0])
            {
                var obj : away.containers.ObjectContainer3D = ( &lt;away.containers.ObjectContainer3D&gt; returnedArray[1] ).addChild(ctr);
                parentName = (&lt;away.containers.ObjectContainer3D&gt; returnedArray[1]).name;
            }
            else if (par_id &gt; 0)
            {
                this._blocks[ blockID ].addError(&quot;Could not find a parent for this ObjectContainer3D&quot;);
            }

            // in AWD version 2.1 we read the Container properties
            if ((this._version[0] == 2) &amp;&amp; (this._version[1] == 1))
            {
                var props:AWDProperties = this.parseProperties({1:this._matrixNrType, 2:this._matrixNrType, 3:this._matrixNrType, 4:AWDParser.UINT8});
                ctr.pivotPoint = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
            }
            // in other versions we do not read the Container properties
            else
            {
                this.parseProperties(null);
            }

            // the extraProperties should only be set for AWD2.1-Files, but is read for both versions
            ctr.extra = this.parseUserAttributes();

            this._pFinalizeAsset( &lt;away.library.IAsset&gt; ctr, name);
            this._blocks[blockID].data = ctr;

            if (this._debug)
            {
                console.log(&quot;Parsed a Container: Name = &#x27;&quot; + name + &quot;&#x27; | Parent-Name = &quot; + parentName);
            }
        }

        // Block ID = 23
        private parseMeshInstance(blockID:number):void
        {
            var num_materials:number;
            var materials_parsed:number;
            var parent:away.containers.ObjectContainer3D;
            var par_id:number = this._newBlockBytes.readUnsignedInt();
            var mtx:away.geom.Matrix3D = this.parseMatrix3D();
            var name:string = this.parseVarStr();
            var parentName:string = &quot;Root (TopLevel)&quot;;
            var data_id:number = this._newBlockBytes.readUnsignedInt();
            var geom:away.base.Geometry;
            var returnedArrayGeometry:Array&lt;any&gt; = this.getAssetByID(data_id, [away.library.AssetType.GEOMETRY])

            if (returnedArrayGeometry[0])
            {
                geom = &lt;away.base.Geometry&gt; returnedArrayGeometry[1];
            }
            else
            {
                this._blocks[blockID].addError(&quot;Could not find a Geometry for this Mesh. A empty Geometry is created!&quot;);
                geom = new away.base.Geometry();
            }

            this._blocks[blockID].geoID = data_id;
            var materials:Array&lt;away.materials.MaterialBase&gt; = new Array&lt;away.materials.MaterialBase&gt;();
            num_materials = this._newBlockBytes.readUnsignedShort();

            var materialNames:Array&lt;string&gt; = new Array&lt;string&gt;();
            materials_parsed = 0;

            var returnedArrayMaterial:Array&lt;any&gt;;

            while (materials_parsed &lt; num_materials)
            {
                var mat_id:number;
                mat_id = this._newBlockBytes.readUnsignedInt();
                returnedArrayMaterial = this.getAssetByID(mat_id, [away.library.AssetType.MATERIAL])
                if ((!returnedArrayMaterial[0]) &amp;&amp; (mat_id &gt; 0))
                {
                    this._blocks[blockID].addError(&quot;Could not find Material Nr &quot; + materials_parsed + &quot; (ID = &quot; + mat_id + &quot; ) for this Mesh&quot;);
                }

                var m : away.materials.MaterialBase = &lt;away.materials.MaterialBase&gt; returnedArrayMaterial[1];

                materials.push(m);
                materialNames.push(m.name);

                materials_parsed++;
            }

            var mesh:away.entities.Mesh = new away.entities.Mesh(geom, null);
                mesh.transform = mtx;

            var returnedArrayParent:Array&lt;any&gt; = this.getAssetByID(par_id, [away.library.AssetType.CONTAINER, away.library.AssetType.LIGHT, away.library.AssetType.MESH, away.library.AssetType.ENTITY, away.library.AssetType.SEGMENT_SET])

            if (returnedArrayParent[0])
            {
                var objC : away.containers.ObjectContainer3D = &lt;away.containers.ObjectContainer3D&gt; returnedArrayParent[1];
                    objC.addChild(mesh);
                parentName = objC.name;
            }
            else if (par_id &gt; 0)
            {
                this._blocks[blockID].addError(&quot;Could not find a parent for this Mesh&quot;);
            }

            if (materials.length &gt;= 1 &amp;&amp; mesh.subMeshes.length == 1)
            {
                mesh.material = materials[0];
            }
            else if (materials.length &gt; 1)
            {
                var i:number;

                // Assign each sub-mesh in the mesh a material from the list. If more sub-meshes
                // than materials, repeat the last material for all remaining sub-meshes.
                for (i = 0; i &lt; mesh.subMeshes.length; i++)
                {
                    mesh.subMeshes[i].material = materials[Math.min(materials.length - 1, i)];
                }
            }
            if ((this._version[0] == 2) &amp;&amp; (this._version[1] == 1))
            {
                var props:AWDProperties = this.parseProperties({1:this._matrixNrType, 2:this._matrixNrType, 3:this._matrixNrType, 4:AWDParser.UINT8, 5:AWDParser.BOOL});
                mesh.pivotPoint = new away.geom.Vector3D(&lt;number&gt;props.get(1, 0), &lt;number&gt;props.get(2, 0), &lt;number&gt; props.get(3, 0));
                mesh.castsShadows = props.get(5, true);
            }
            else
            {
                this.parseProperties(null);
            }

            mesh.extra = this.parseUserAttributes();

            this._pFinalizeAsset( &lt;away.library.IAsset&gt; mesh, name);
            this._blocks[blockID].data = mesh;

            if (this._debug)
            {
                console.log(&quot;Parsed a Mesh: Name = &#x27;&quot; + name + &quot;&#x27; | Parent-Name = &quot; + parentName + &quot;| Geometry-Name = &quot; + geom.name + &quot; | SubMeshes = &quot; + mesh.subMeshes.length + &quot; | Mat-Names = &quot; + materialNames.toString());
            }
        }

        //Block ID = 41
        private parseLight(blockID:number):void
        {
            var light           : away.lights.LightBase;
            var newShadowMapper : away.lights.ShadowMapperBase;

            var par_id          : number                = this._newBlockBytes.readUnsignedInt();
            var mtx             : away.geom.Matrix3D    = this.parseMatrix3D();
            var name            : string                = this.parseVarStr();
            var lightType       : number                = this._newBlockBytes.readUnsignedByte();
            var props           : AWDProperties         = this.parseProperties({1:this._propsNrType, 2:this._propsNrType, 3:AWDParser.COLOR, 4:this._propsNrType, 5:this._propsNrType, 6:AWDParser.BOOL, 7:AWDParser.COLOR, 8:this._propsNrType, 9:AWDParser.UINT8, 10:AWDParser.UINT8, 11:this._propsNrType, 12:AWDParser.UINT16, 21:this._matrixNrType, 22:this._matrixNrType, 23:this._matrixNrType});
            var shadowMapperType: number                = props.get(9, 0);
            var parentName      : string                = &quot;Root (TopLevel)&quot;;
            var lightTypes      : Array&lt;string&gt;         = [&quot;Unsupported LightType&quot;, &quot;PointLight&quot;, &quot;DirectionalLight&quot;];
            var shadowMapperTypes : Array&lt;string&gt;       = [&quot;No ShadowMapper&quot;, &quot;DirectionalShadowMapper&quot;, &quot;NearDirectionalShadowMapper&quot;, &quot;CascadeShadowMapper&quot;, &quot;CubeMapShadowMapper&quot;];

            if (lightType == 1)
            {
                light = new away.lights.PointLight();

                (&lt;away.lights.PointLight&gt; light).radius     = props.get(1, 90000);
                (&lt;away.lights.PointLight&gt; light).fallOff    = props.get(2, 100000);

                if (shadowMapperType &gt; 0)
                {
                    if (shadowMapperType == 4)
                    {
                        newShadowMapper = new away.lights.CubeMapShadowMapper();
                    }
                }

                light.transform = mtx;

            }

            if (lightType == 2)
            {

                light = new away.lights.DirectionalLight(props.get(21, 0), props.get(22, -1), props.get(23, 1));

                if (shadowMapperType &gt; 0)
                {
                    if (shadowMapperType == 1)
                    {
                        newShadowMapper = new away.lights.DirectionalShadowMapper();
                    }

                    //if (shadowMapperType == 2)
                    //  newShadowMapper = new NearDirectionalShadowMapper(props.get(11, 0.5));
                    //if (shadowMapperType == 3)
                    //   newShadowMapper = new CascadeShadowMapper(props.get(12, 3));

                }

            }
            light.color         = props.get(3, 0xffffff);
            light.specular      = props.get(4, 1.0);
            light.diffuse       = props.get(5, 1.0);
            light.ambientColor  = props.get(7, 0xffffff);
            light.ambient       = props.get(8, 0.0);

            // if a shadowMapper has been created, adjust the depthMapSize if needed, assign to light and set castShadows to true
            if (newShadowMapper)
            {
                if (newShadowMapper instanceof away.lights.CubeMapShadowMapper )
                {
                    if (props.get(10, 1) != 1)
                    {
                        newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 1)];
                    }
                }
                else
                {
                    if (props.get(10, 2) != 2)
                    {
                        newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 2)];
                    }
                }

                light.shadowMapper = newShadowMapper;
                light.castsShadows = true;
            }

            if (par_id != 0)
            {

                var returnedArrayParent : Array&lt;any&gt; = this.getAssetByID(par_id, [away.library.AssetType.CONTAINER, away.library.AssetType.LIGHT, away.library.AssetType.MESH, away.library.AssetType.ENTITY, away.library.AssetType.SEGMENT_SET])

                if (returnedArrayParent[0])
                {
                    (&lt;away.containers.ObjectContainer3D&gt; returnedArrayParent[1]).addChild(light);
                    parentName = (&lt;away.containers.ObjectContainer3D&gt; returnedArrayParent[1]).name;
                }
                else
                {
                    this._blocks[blockID].addError(&quot;Could not find a parent for this Light&quot;);
                }
            }

            this.parseUserAttributes();

            this._pFinalizeAsset( &lt; away.library.IAsset&gt; light, name);

            this._blocks[blockID].data = light;

            if (this._debug)
                console.log(&quot;Parsed a Light: Name = &#x27;&quot; + name + &quot;&#x27; | Type = &quot; + lightTypes[lightType] + &quot; | Parent-Name = &quot; + parentName + &quot; | ShadowMapper-Type = &quot; + shadowMapperTypes[shadowMapperType]);

        }

        //Block ID = 43
        private parseCamera(blockID:number):void
        {

            var par_id      : number                = this._newBlockBytes.readUnsignedInt();
            var mtx         : away.geom.Matrix3D    = this.parseMatrix3D();
            var name        : string                = this.parseVarStr();
            var parentName  : string                = &quot;Root (TopLevel)&quot;;
            var lens        : away.cameras.LensBase;

            this._newBlockBytes.readUnsignedByte(); //set as active camera
            this._newBlockBytes.readShort(); //lengthof lenses - not used yet

            var lenstype    : number        = this._newBlockBytes.readShort();
            var props       : AWDProperties = this.parseProperties({101:this._propsNrType, 102:this._propsNrType, 103:this._propsNrType, 104:this._propsNrType});

            switch (lenstype)
            {
                case 5001:
                    lens = new away.cameras.PerspectiveLens(props.get(101, 60));
                    break;
                case 5002:
                    lens = new away.cameras.OrthographicLens(props.get(101, 500));
                    break;
                case 5003:
                    lens = new away.cameras.OrthographicOffCenterLens(props.get(101, -400), props.get(102, 400), props.get(103, -300), props.get(104, 300));
                    break;
                default:
                    console.log(&quot;unsupportedLenstype&quot;);
                    return;
            }

            var camera:away.cameras.Camera3D    = new away.cameras.Camera3D(lens);
                camera.transform                = mtx;

            var returnedArrayParent:Array&lt;any&gt;  = this.getAssetByID(par_id, [away.library.AssetType.CONTAINER, away.library.AssetType.LIGHT, away.library.AssetType.MESH, away.library.AssetType.ENTITY, away.library.AssetType.SEGMENT_SET])

            if (returnedArrayParent[0])
            {

                var objC : away.containers.ObjectContainer3D = &lt;away.containers.ObjectContainer3D&gt; returnedArrayParent[1];
                    objC.addChild(camera);

                parentName = objC.name;

            }
            else if (par_id &gt; 0)
            {
                this._blocks[blockID].addError(&quot;Could not find a parent for this Camera&quot;);
            }

            camera.name         = name;
            props               = this.parseProperties({1:this._matrixNrType, 2:this._matrixNrType, 3:this._matrixNrType, 4:AWDParser.UINT8});
            camera.pivotPoint   = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
            camera.extra        = this.parseUserAttributes();

            this._pFinalizeAsset(camera, name);

            this._blocks[blockID].data = camera

            if (this._debug)
            {
                console.log(&quot;Parsed a Camera: Name = &#x27;&quot; + name + &quot;&#x27; | Lenstype = &quot; + lens + &quot; | Parent-Name = &quot; + parentName);
            }

        }

        //Block ID = 51
        private parseLightPicker(blockID:number):void
        {
            var name        : string                            = this.parseVarStr();
            var numLights   : number                            = this._newBlockBytes.readUnsignedShort();
            var lightsArray : Array&lt;away.lights.LightBase&gt;      = new Array&lt;away.lights.LightBase&gt;();
            var k           : number                            = 0;
            var lightID     : number                            = 0;

            var returnedArrayLight  : Array&lt;any&gt;;
            var lightsArrayNames    : Array&lt;string&gt;             = new Array&lt;string&gt;();

            for (k = 0; k &lt; numLights; k++)
            {
                lightID             = this._newBlockBytes.readUnsignedInt();
                returnedArrayLight  = this.getAssetByID(lightID, [away.library.AssetType.LIGHT])

                if (returnedArrayLight[0])
                {
                    lightsArray.push( &lt;away.lights.LightBase&gt; returnedArrayLight[1] );
                    lightsArrayNames.push( ( &lt;away.lights.LightBase&gt; returnedArrayLight[1]).name );

                }
                else
                {
                    this._blocks[blockID].addError(&quot;Could not find a Light Nr &quot; + k + &quot; (ID = &quot; + lightID + &quot; ) for this LightPicker&quot;);
                }
            }

            if (lightsArray.length == 0)
            {
                this._blocks[blockID].addError(&quot;Could not create this LightPicker, cause no Light was found.&quot;);
                this.parseUserAttributes();
                return; //return without any more parsing for this block
            }

            var lightPick:away.materials.LightPickerBase    = new away.materials.StaticLightPicker(lightsArray);
                lightPick.name                              = name;

            this.parseUserAttributes();
            this._pFinalizeAsset( &lt;away.library.IAsset&gt; lightPick, name);

            this._blocks[blockID].data = lightPick
            if (this._debug)
            {
                console.log(&quot;Parsed a StaticLightPicker: Name = &#x27;&quot; + name + &quot;&#x27; | Texture-Name = &quot; + lightsArrayNames.toString());
            }
        }

        //Block ID = 81
        private parseMaterial(blockID:number):void
        {
            // TODO: not used
            ////blockLength = block.len;
            var name:string;
            var type:number;
            var props:AWDProperties;
            var mat:away.materials.MaterialBase;
            var attributes:Object;
            var finalize:boolean;
            var num_methods:number;
            var methods_parsed:number;
            var returnedArray:Array&lt;any&gt;;

            name = this.parseVarStr();
            type = this._newBlockBytes.readUnsignedByte();
            num_methods = this._newBlockBytes.readUnsignedByte();

            // Read material numerical properties
            // (1=color, 2=bitmap url, 10=alpha, 11=alpha_blending, 12=alpha_threshold, 13=repeat)
            props = this.parseProperties( { 1:AWDParser.INT32, 2:AWDParser.BADDR, 10:this._propsNrType, 11:AWDParser.BOOL, 12:this._propsNrType, 13:AWDParser.BOOL});

            methods_parsed = 0;
            while (methods_parsed &lt; num_methods)
            {
                var method_type:number;

                method_type = this._newBlockBytes.readUnsignedShort();
                this.parseProperties(null);
                this.parseUserAttributes();
                methods_parsed += 1;
            }
            var debugString:string = &quot;&quot;;
            attributes = this.parseUserAttributes();
            if (type === 1) { // Color material
                debugString += &quot;Parsed a ColorMaterial(SinglePass): Name = &#x27;&quot; + name + &quot;&#x27; | &quot;;
                var color:number;
                color = props.get(1, 0xcccccc);
                if (this.materialMode &lt; 2)
                    mat = new away.materials.ColorMaterial(color, props.get(10, 1.0));
                else
                    mat = new away.materials.ColorMultiPassMaterial(color);

            }
            else if (type === 2)
            {
                var tex_addr:number = props.get(2, 0);

                returnedArray = this.getAssetByID(tex_addr, [away.library.AssetType.TEXTURE])
                if ((!returnedArray[0]) &amp;&amp; (tex_addr &gt; 0))
                {
                    this._blocks[blockID].addError(&quot;Could not find the DiffsueTexture (ID = &quot; + tex_addr + &quot; ) for this Material&quot;);
                }

                if (this.materialMode &lt; 2)
                {
                    mat = &lt;away.materials.MaterialBase&gt; new away.materials.TextureMaterial( &lt;away.textures.Texture2DBase&gt; returnedArray[1]);

                    var txMaterial : away.materials.TextureMaterial = &lt;away.materials.TextureMaterial&gt; mat;

                    txMaterial.alphaBlending = props.get(11, false);
                    txMaterial.alpha = props.get(10, 1.0);
                    debugString += &quot;Parsed a TextureMaterial(SinglePass): Name = &#x27;&quot; + name + &quot;&#x27; | Texture-Name = &quot; + mat.name;
                }
                else
                {
                    mat = &lt;away.materials.MaterialBase&gt; new away.materials.TextureMultiPassMaterial(returnedArray[1]);
                    debugString += &quot;Parsed a TextureMaterial(MultipAss): Name = &#x27;&quot; + name + &quot;&#x27; | Texture-Name = &quot; + mat.name;
                }
            }

            mat.extra = attributes;
            if (this.materialMode &lt; 2)
            {

                var spmb : away.materials.SinglePassMaterialBase = &lt;away.materials.SinglePassMaterialBase&gt; mat;
                spmb.alphaThreshold = props.get(12, 0.0);

            }
            else
            {
                var mpmb : away.materials.MultiPassMaterialBase = &lt;away.materials.MultiPassMaterialBase&gt; mat;
                mpmb.alphaThreshold = props.get(12, 0.0);
            }


            mat.repeat = props.get(13, false);
            this._pFinalizeAsset( &lt;away.library.IAsset&gt; mat, name);
            this._blocks[blockID].data = mat;

            if (this._debug)
            {
                console.log(debugString);

            }
        }

        // Block ID = 81 AWD2.1
        private parseMaterial_v1(blockID:number):void
        {
            var mat                 : away.materials.MaterialBase;
            var normalTexture       : away.textures.Texture2DBase;
            var specTexture         : away.textures.Texture2DBase;
            var returnedArray       : Array&lt;any&gt;;

            var name                : string        = this.parseVarStr();
            var type                : number        = this._newBlockBytes.readUnsignedByte();
            var num_methods         : number        = this._newBlockBytes.readUnsignedByte();
            var props               : AWDProperties = this.parseProperties({1:AWDParser.UINT32, 2:AWDParser.BADDR, 3:AWDParser.BADDR, 4:AWDParser.UINT8, 5:AWDParser.BOOL, 6:AWDParser.BOOL, 7:AWDParser.BOOL, 8:AWDParser.BOOL, 9:AWDParser.UINT8, 10:this._propsNrType, 11:AWDParser.BOOL, 12:this._propsNrType, 13:AWDParser.BOOL, 15:this._propsNrType, 16:AWDParser.UINT32, 17:AWDParser.BADDR, 18:this._propsNrType, 19:this._propsNrType, 20:AWDParser.UINT32, 21:AWDParser.BADDR, 22:AWDParser.BADDR});
            var spezialType         : number        = props.get(4, 0);
            var debugString         : string        = &quot;&quot;;

            if (spezialType &gt;= 2)//this is no supported material
            {
                this._blocks[blockID].addError(&quot;Material-spezialType &#x27;&quot; + spezialType + &quot;&#x27; is not supported, can only be 0:singlePass, 1:MultiPass !&quot;);
                return;
            }

            if (this.materialMode == 1)
            {
                spezialType = 0;
            }
            else if (this.materialMode == 2)
            {
                spezialType = 1;
            }

            if (spezialType &lt; 2)//this is SinglePass or MultiPass
            {
                if (type == 1)// Color material
                {
                    var color : number = props.get(1, 0xcccccc);//var color : number = color = props.get(1, 0xcccccc);

                    if (spezialType == 1)//	MultiPassMaterial
                    {
                        mat         = new away.materials.ColorMultiPassMaterial(color);
                        debugString += &quot;Parsed a ColorMaterial(MultiPass): Name = &#x27;&quot; + name + &quot;&#x27; | &quot;;
                    }
                    else //	SinglePassMaterial
                    {
                        mat = new away.materials.ColorMaterial(color, props.get(10, 1.0));
                        (&lt;away.materials.ColorMaterial&gt; mat).alphaBlending = props.get(11, false);
                        debugString += &quot;Parsed a ColorMaterial(SinglePass): Name = &#x27;&quot; + name + &quot;&#x27; | &quot;;
                    }
                }
                else if (type == 2)// texture material
                {

                    var tex_addr    : number    = props.get(2, 0);
                    returnedArray               = this.getAssetByID(tex_addr, [away.library.AssetType.TEXTURE]);

                    if ((!returnedArray[0]) &amp;&amp; (tex_addr &gt; 0))
                    {
                        this._blocks[blockID].addError(&quot;Could not find the DiffuseTexture (ID = &quot; + tex_addr + &quot; ) for this TextureMaterial&quot;);
                    }
                    var texture         : away.textures.Texture2DBase = returnedArray[1];
                    var ambientTexture  : away.textures.Texture2DBase;
                    var ambientTex_addr : number = props.get(17, 0);

                    returnedArray = this.getAssetByID(ambientTex_addr, [away.library.AssetType.TEXTURE]);

                    if ((!returnedArray[0]) &amp;&amp; (ambientTex_addr != 0))
                    {
                        this._blocks[blockID].addError(&quot;Could not find the AmbientTexture (ID = &quot; + ambientTex_addr + &quot; ) for this TextureMaterial&quot;);
                    }

                    if (returnedArray[0])
                    {
                        ambientTexture = returnedArray[1]
                    }

                    if (spezialType == 1)// MultiPassMaterial
                    {
                        mat         = new away.materials.TextureMultiPassMaterial(texture);
                        debugString += &quot;Parsed a TextureMaterial(MultiPass): Name = &#x27;&quot; + name + &quot;&#x27; | Texture-Name = &quot; + texture.name;

                        if (ambientTexture)
                        {
                            ( &lt;away.materials.TextureMultiPassMaterial&gt; mat).ambientTexture = ambientTexture;
                            debugString += &quot; | AmbientTexture-Name = &quot; + ambientTexture.name;
                        }
                    }
                    else//	SinglePassMaterial
                    {
                        mat         = new away.materials.TextureMaterial(texture);
                        debugString += &quot;Parsed a TextureMaterial(SinglePass): Name = &#x27;&quot; + name + &quot;&#x27; | Texture-Name = &quot; + texture.name;

                        if (ambientTexture)
                        {
                            (&lt;away.materials.TextureMaterial&gt; mat).ambientTexture = ambientTexture;
                            debugString += &quot; | AmbientTexture-Name = &quot; + ambientTexture.name;
                        }

                        (&lt;away.materials.TextureMaterial&gt; mat).alpha = props.get(10, 1.0);
                        (&lt;away.materials.TextureMaterial&gt; mat).alphaBlending = props.get(11, false);
                    }

                }

                var normalTex_addr:number = props.get(3, 0);

                returnedArray = this.getAssetByID(normalTex_addr, [away.library.AssetType.TEXTURE]);

                if ((!returnedArray[0]) &amp;&amp; (normalTex_addr != 0))
                {
                    this._blocks[blockID].addError(&quot;Could not find the NormalTexture (ID = &quot; + normalTex_addr + &quot; ) for this TextureMaterial&quot;);
                }

                if (returnedArray[0])
                {
                    normalTexture = returnedArray[1];
                    debugString += &quot; | NormalTexture-Name = &quot; + normalTexture.name;
                }

                var specTex_addr : number = props.get(21, 0);
                returnedArray = this.getAssetByID(specTex_addr, [away.library.AssetType.TEXTURE]);

                if ((!returnedArray[0]) &amp;&amp; (specTex_addr != 0))
                {
                    this._blocks[blockID].addError(&quot;Could not find the SpecularTexture (ID = &quot; + specTex_addr + &quot; ) for this TextureMaterial&quot;);
                }
                if (returnedArray[0])
                {
                    specTexture = returnedArray[1];
                    debugString += &quot; | SpecularTexture-Name = &quot; + specTexture.name;
                }

                var lightPickerAddr : number = props.get(22, 0);
                returnedArray = this.getAssetByID(lightPickerAddr, [away.library.AssetType.LIGHT_PICKER])

                if ((!returnedArray[0]) &amp;&amp; (lightPickerAddr))
                {
                    this._blocks[blockID].addError(&quot;Could not find the LightPicker (ID = &quot; + lightPickerAddr + &quot; ) for this TextureMaterial&quot;);
                }
                else
                {
                    (&lt;away.materials.MaterialBase&gt; mat).lightPicker = &lt;away.materials.LightPickerBase&gt; returnedArray[1] ;
                    //debugString+=&quot; | Lightpicker-Name = &quot;+LightPickerBase(returnedArray[1]).name;
                }

                (&lt;away.materials.MaterialBase&gt; mat).smooth              = props.get(5, true);
                (&lt;away.materials.MaterialBase&gt; mat).mipmap              = props.get(6, true);
                (&lt;away.materials.MaterialBase&gt; mat).bothSides           = props.get(7, false);
                (&lt;away.materials.MaterialBase&gt; mat).alphaPremultiplied  = props.get(8, false);
                (&lt;away.materials.MaterialBase&gt; mat).blendMode           = this.blendModeDic[props.get(9, 0)];
                (&lt;away.materials.MaterialBase&gt; mat).repeat              = props.get(13, false);

                if (spezialType == 0)// this is a SinglePassMaterial
                {
                    if (normalTexture)
                    {
                        (&lt;away.materials.SinglePassMaterialBase&gt; mat).normalMap = normalTexture;
                    }
                    if (specTexture)
                    {
                        (&lt;away.materials.SinglePassMaterialBase&gt; mat).specularMap = specTexture;
                    }

                    (&lt;away.materials.SinglePassMaterialBase&gt; mat).alphaThreshold    = props.get(12, 0.0);
                    (&lt;away.materials.SinglePassMaterialBase&gt; mat).ambient           = props.get(15, 1.0);
                    (&lt;away.materials.SinglePassMaterialBase&gt; mat).ambientColor      = props.get(16, 0xffffff);
                    (&lt;away.materials.SinglePassMaterialBase&gt; mat).specular          = props.get(18, 1.0);
                    (&lt;away.materials.SinglePassMaterialBase&gt; mat).gloss             = props.get(19, 50);
                    (&lt;away.materials.SinglePassMaterialBase&gt; mat).specularColor     = props.get(20, 0xffffff);
                }
                else // this is MultiPassMaterial
                {
                    if (normalTexture)
                    {
                        (&lt;away.materials.MultiPassMaterialBase&gt; mat).normalMap = normalTexture;
                    }
                    if (specTexture)
                    {
                        (&lt;away.materials.MultiPassMaterialBase&gt; mat).specularMap = specTexture;
                    }

                    (&lt;away.materials.MultiPassMaterialBase&gt; mat).alphaThreshold = props.get(12, 0.0);
                    (&lt;away.materials.MultiPassMaterialBase&gt; mat).ambient        = props.get(15, 1.0);
                    (&lt;away.materials.MultiPassMaterialBase&gt; mat).ambientColor   = props.get(16, 0xffffff);
                    (&lt;away.materials.MultiPassMaterialBase&gt; mat).specular       = props.get(18, 1.0);
                    (&lt;away.materials.MultiPassMaterialBase&gt; mat).gloss          = props.get(19, 50);
                    (&lt;away.materials.MultiPassMaterialBase&gt; mat).specularColor  = props.get(20, 0xffffff);

                }

                var methods_parsed  : number = 0;
                var targetID        : number;

                while (methods_parsed &lt; num_methods)
                {
                    var method_type : number ;
                        method_type = this._newBlockBytes.readUnsignedShort();

                    props = this.parseProperties({1:AWDParser.BADDR, 2:AWDParser.BADDR, 3:AWDParser.BADDR, 101:this._propsNrType, 102:this._propsNrType, 103:this._propsNrType, 201:AWDParser.UINT32, 202:AWDParser.UINT32, 301:AWDParser.UINT16, 302:AWDParser.UINT16, 401:AWDParser.UINT8, 402:AWDParser.UINT8, 601:AWDParser.COLOR, 602:AWDParser.COLOR, 701:AWDParser.BOOL, 702:AWDParser.BOOL, 801:AWDParser.MTX4x4});

                    switch (method_type)
                    {
                        case 999: //wrapper-Methods that will load a previous parsed EffektMethod returned

                            targetID = props.get(1, 0);
                            returnedArray = this.getAssetByID(targetID, [away.library.AssetType.EFFECTS_METHOD]);

                            if (!returnedArray[0])
                            {
                                this._blocks[blockID].addError(&quot;Could not find the EffectMethod (ID = &quot; + targetID + &quot; ) for this Material&quot;);
                            }
                            else
                            {
                                if (spezialType == 0)
                                {
                                    (&lt;away.materials.SinglePassMaterialBase&gt; mat).addMethod(returnedArray[1]);
                                }
                                if (spezialType == 1)
                                {
                                    (&lt;away.materials.MultiPassMaterialBase&gt; mat).addMethod(returnedArray[1]);
                                }

                                debugString += &quot; | EffectMethod-Name = &quot; + (&lt;away.materials.EffectMethodBase&gt; returnedArray[1]).name;
                            }

                            break;

                        case 998: //wrapper-Methods that will load a previous parsed ShadowMapMethod

                            targetID = props.get(1, 0);
                            returnedArray = this.getAssetByID(targetID, [away.library.AssetType.SHADOW_MAP_METHOD]);

                            if (!returnedArray[0])
                            {
                                this._blocks[blockID].addError(&quot;Could not find the ShadowMethod (ID = &quot; + targetID + &quot; ) for this Material&quot;);
                            }
                            else
                            {
                                if (spezialType == 0)
                                {
                                    (&lt;away.materials.SinglePassMaterialBase&gt; mat).shadowMethod = returnedArray[1];
                                }

                                if (spezialType == 1)
                                {
                                    (&lt;away.materials.MultiPassMaterialBase&gt; mat).shadowMethod = returnedArray[1];
                                }

                                debugString += &quot; | ShadowMethod-Name = &quot; + (&lt;away.materials.ShadowMapMethodBase&gt; returnedArray[1]).name;

                            }

                            break;

    //						case 1: //EnvMapAmbientMethod
    //							targetID = props.get(1, 0);
    //							returnedArray = getAssetByID(targetID, [AssetType.TEXTURE], &quot;CubeTexture&quot;);
    //							if (!returnedArray[0])
    //								_blocks[blockID].addError(&quot;Could not find the EnvMap (ID = &quot; + targetID + &quot; ) for this EnvMapAmbientMethodMaterial&quot;);
    //							if (spezialType == 0)
    //								SinglePassMaterialBase(mat).ambientMethod = new EnvMapAmbientMethod(returnedArray[1]);
    //							if (spezialType == 1)
    //								MultiPassMaterialBase(mat).ambientMethod = new EnvMapAmbientMethod(returnedArray[1]);
    //							debugString += &quot; | EnvMapAmbientMethod | EnvMap-Name =&quot; + CubeTextureBase(returnedArray[1]).name;
    //							break;
    //
    //						case 51: //DepthDiffuseMethod
    //							if (spezialType == 0)
    //								SinglePassMaterialBase(mat).diffuseMethod = new DepthDiffuseMethod();
    //							if (spezialType == 1)
    //								MultiPassMaterialBase(mat).diffuseMethod = new DepthDiffuseMethod();
    //							debugString += &quot; | DepthDiffuseMethod&quot;;
    //							break;
    //						case 52: //GradientDiffuseMethod
    //							targetID = props.get(1, 0);
    //							returnedArray = getAssetByID(targetID, [AssetType.TEXTURE]);
    //							if (!returnedArray[0])
    //								_blocks[blockID].addError(&quot;Could not find the GradientDiffuseTexture (ID = &quot; + targetID + &quot; ) for this GradientDiffuseMethod&quot;);
    //							if (spezialType == 0)
    //								SinglePassMaterialBase(mat).diffuseMethod = new GradientDiffuseMethod(returnedArray[1]);
    //							if (spezialType == 1)
    //								MultiPassMaterialBase(mat).diffuseMethod = new GradientDiffuseMethod(returnedArray[1]);
    //							debugString += &quot; | GradientDiffuseMethod | GradientDiffuseTexture-Name =&quot; + Texture2DBase(returnedArray[1]).name;
    //							break;
    //						case 53: //WrapDiffuseMethod
    //							if (spezialType == 0)
    //								SinglePassMaterialBase(mat).diffuseMethod = new WrapDiffuseMethod(props.get(101, 5));
    //							if (spezialType == 1)
    //								MultiPassMaterialBase(mat).diffuseMethod = new WrapDiffuseMethod(props.get(101, 5));
    //							debugString += &quot; | WrapDiffuseMethod&quot;;
    //							break;
    //						case 54: //LightMapDiffuseMethod
    //							targetID = props.get(1, 0);
    //							returnedArray = getAssetByID(targetID, [AssetType.TEXTURE]);
    //							if (!returnedArray[0])
    //								_blocks[blockID].addError(&quot;Could not find the LightMap (ID = &quot; + targetID + &quot; ) for this LightMapDiffuseMethod&quot;);
    //							if (spezialType == 0)
    //								SinglePassMaterialBase(mat).diffuseMethod = new LightMapDiffuseMethod(returnedArray[1], blendModeDic[props.get(401, 10)], false, SinglePassMaterialBase(mat).diffuseMethod);
    //							if (spezialType == 1)
    //								MultiPassMaterialBase(mat).diffuseMethod = new LightMapDiffuseMethod(returnedArray[1], blendModeDic[props.get(401, 10)], false, MultiPassMaterialBase(mat).diffuseMethod);
    //							debugString += &quot; | LightMapDiffuseMethod | LightMapTexture-Name =&quot; + Texture2DBase(returnedArray[1]).name;
    //							break;
    //						case 55: //CelDiffuseMethod
    //							if (spezialType == 0) {
    //								SinglePassMaterialBase(mat).diffuseMethod = new CelDiffuseMethod(props.get(401, 3), SinglePassMaterialBase(mat).diffuseMethod);
    //								CelDiffuseMethod(SinglePassMaterialBase(mat).diffuseMethod).smoothness = props.get(101, 0.1);
    //							}
    //							if (spezialType == 1) {
    //								MultiPassMaterialBase(mat).diffuseMethod = new CelDiffuseMethod(props.get(401, 3), MultiPassMaterialBase(mat).diffuseMethod);
    //								CelDiffuseMethod(MultiPassMaterialBase(mat).diffuseMethod).smoothness = props.get(101, 0.1);
    //							}
    //							debugString += &quot; | CelDiffuseMethod&quot;;
    //							break;
    //						case 56: //SubSurfaceScatteringMethod
    //							if (spezialType == 0) {
    //								SinglePassMaterialBase(mat).diffuseMethod = new SubsurfaceScatteringDiffuseMethod(); //depthMapSize and depthMapOffset ?
    //								SubsurfaceScatteringDiffuseMethod(SinglePassMaterialBase(mat).diffuseMethod).scattering = props.get(101, 0.2);
    //								SubsurfaceScatteringDiffuseMethod(SinglePassMaterialBase(mat).diffuseMethod).translucency = props.get(102, 1);
    //								SubsurfaceScatteringDiffuseMethod(SinglePassMaterialBase(mat).diffuseMethod).scatterColor = props.get(601, 0xffffff);
    //							}
    //							if (spezialType == 1) {
    //								MultiPassMaterialBase(mat).diffuseMethod = new SubsurfaceScatteringDiffuseMethod(); //depthMapSize and depthMapOffset ?
    //								SubsurfaceScatteringDiffuseMethod(MultiPassMaterialBase(mat).diffuseMethod).scattering = props.get(101, 0.2);
    //								SubsurfaceScatteringDiffuseMethod(MultiPassMaterialBase(mat).diffuseMethod).translucency = props.get(102, 1);
    //								SubsurfaceScatteringDiffuseMethod(MultiPassMaterialBase(mat).diffuseMethod).scatterColor = props.get(601, 0xffffff);
    //							}
    //							debugString += &quot; | SubSurfaceScatteringMethod&quot;;
    //							break;
    //
    //						case 101: //AnisotropicSpecularMethod
    //							if (spezialType == 0)
    //								SinglePassMaterialBase(mat).specularMethod = new AnisotropicSpecularMethod();
    //							if (spezialType == 1)
    //								MultiPassMaterialBase(mat).specularMethod = new AnisotropicSpecularMethod();
    //							debugString += &quot; | AnisotropicSpecularMethod&quot;;
    //							break;
    //						case 102: //PhongSpecularMethod
    //							if (spezialType == 0)
    //								SinglePassMaterialBase(mat).specularMethod = new PhongSpecularMethod();
    //							if (spezialType == 1)
    //								MultiPassMaterialBase(mat).specularMethod = new PhongSpecularMethod();
    //							debugString += &quot; | PhongSpecularMethod&quot;;
    //							break;
    //						case 103: //CellSpecularMethod
    //							if (spezialType == 0) {
    //								SinglePassMaterialBase(mat).specularMethod = new CelSpecularMethod(props.get(101, 0.5), SinglePassMaterialBase(mat).specularMethod);
    //								CelSpecularMethod(SinglePassMaterialBase(mat).specularMethod).smoothness = props.get(102, 0.1);
    //							}
    //							if (spezialType == 1) {
    //								MultiPassMaterialBase(mat).specularMethod = new CelSpecularMethod(props.get(101, 0.5), MultiPassMaterialBase(mat).specularMethod);
    //								CelSpecularMethod(MultiPassMaterialBase(mat).specularMethod).smoothness = props.get(102, 0.1);
    //							}
    //							debugString += &quot; | CellSpecularMethod&quot;;
    //							break;
    //						case 104: //FresnelSpecularMethod
    //							if (spezialType == 0) {
    //								SinglePassMaterialBase(mat).specularMethod = new FresnelSpecularMethod(props.get(701, true), SinglePassMaterialBase(mat).specularMethod);
    //								FresnelSpecularMethod(SinglePassMaterialBase(mat).specularMethod).fresnelPower = props.get(101, 5);
    //								FresnelSpecularMethod(SinglePassMaterialBase(mat).specularMethod).normalReflectance = props.get(102, 0.1);
    //							}
    //							if (spezialType == 1) {
    //								MultiPassMaterialBase(mat).specularMethod = new FresnelSpecularMethod(props.get(701, true), MultiPassMaterialBase(mat).specularMethod);
    //								FresnelSpecularMethod(MultiPassMaterialBase(mat).specularMethod).fresnelPower = props.get(101, 5);
    //								FresnelSpecularMethod(MultiPassMaterialBase(mat).specularMethod).normalReflectance = props.get(102, 0.1);
    //							}
    //							debugString += &quot; | FresnelSpecularMethod&quot;;
    //							break;
    //						//case 151://HeightMapNormalMethod - thios is not implemented for now, but might appear later
    //						//break;
    //						case 152: //SimpleWaterNormalMethod
    //							targetID = props.get(1, 0);
    //							returnedArray = getAssetByID(targetID, [AssetType.TEXTURE]);
    //							if (!returnedArray[0])
    //								_blocks[blockID].addError(&quot;Could not find the SecoundNormalMap (ID = &quot; + targetID + &quot; ) for this SimpleWaterNormalMethod&quot;);
    //							if (spezialType == 0) {
    //								if (!SinglePassMaterialBase(mat).normalMap)
    //									_blocks[blockID].addError(&quot;Could not find a normal Map on this Material to use with this SimpleWaterNormalMethod&quot;);
    //								SinglePassMaterialBase(mat).normalMap = returnedArray[1];
    //								SinglePassMaterialBase(mat).normalMethod = new SimpleWaterNormalMethod(SinglePassMaterialBase(mat).normalMap, returnedArray[1]);
    //							}
    //							if (spezialType == 1) {
    //								if (!MultiPassMaterialBase(mat).normalMap)
    //									_blocks[blockID].addError(&quot;Could not find a normal Map on this Material to use with this SimpleWaterNormalMethod&quot;);
    //								MultiPassMaterialBase(mat).normalMap = returnedArray[1];
    //								MultiPassMaterialBase(mat).normalMethod = new SimpleWaterNormalMethod(MultiPassMaterialBase(mat).normalMap, returnedArray[1]);
    //							}
    //							debugString += &quot; | SimpleWaterNormalMethod | Second-NormalTexture-Name = &quot; + Texture2DBase(returnedArray[1]).name;
    //							break;
                    }
                    this.parseUserAttributes();
                    methods_parsed += 1;
                }
            }
            (&lt;away.materials.MaterialBase&gt; mat).extra = this.parseUserAttributes();
            this._pFinalizeAsset( &lt;away.library.IAsset&gt; mat, name);

            this._blocks[blockID].data = mat;
            if (this._debug)
            {
                console.log(debugString);
            }
        }

        //Block ID = 82
        private parseTexture(blockID:number):void
        {

            var asset:away.textures.Texture2DBase;

            this._blocks[blockID].name  = this.parseVarStr();

            var type:number             = this._newBlockBytes.readUnsignedByte();
            var data_len:number;

            this._texture_users[this._cur_block_id.toString()] = [];

            // External
            if (type == 0)
            {
                data_len = this._newBlockBytes.readUnsignedInt();
                var url:string;
                url = this._newBlockBytes.readUTFBytes(data_len);
                this._pAddDependency( this._cur_block_id.toString(), new away.net.URLRequest(url), false, null, true);

            }
            else
            {
                data_len = this._newBlockBytes.readUnsignedInt();

                var data:away.utils.ByteArray;
                    data = new away.utils.ByteArray();
                this._newBlockBytes.readBytes( data , 0 , data_len );

                this._pAddDependency(this._cur_block_id.toString(), null, false, data, true);

            }

            // Ignore for now
            this.parseProperties(null);
            this._blocks[blockID].extras = this.parseUserAttributes();
            this._pPauseAndRetrieveDependencies();
            this._blocks[blockID].data = asset;

            if (this._debug)
            {
                var textureStylesNames:Array = [&quot;external&quot;, &quot;embed&quot;]
                console.log(&quot;Start parsing a &quot; + textureStylesNames[type] + &quot; Bitmap for Texture&quot;);
            }

        }

        //Block ID = 83
        private parseCubeTexture(blockID : number ) : void
        {
            //blockLength = block.len;
            var data_len    : number;
            var asset       : away.textures.CubeTextureBase;
            var i           : number;

            this._cubeTextures = new Array&lt;any&gt;();
            this._texture_users[ this._cur_block_id.toString() ] = [];

            var type        : number    = this._newBlockBytes.readUnsignedByte();

            this._blocks[blockID].name  = this.parseVarStr();

            for (i = 0; i &lt; 6; i++)
            {
                this._texture_users[this._cur_block_id.toString()] = [];
                this._cubeTextures.push(null);

                // External
                if (type == 0)
                {
                    data_len    = this._newBlockBytes.readUnsignedInt();
                    var url:string;
                    url         = this._newBlockBytes.readUTFBytes(data_len);

                    this._pAddDependency(  this._cur_block_id.toString() + &quot;#&quot; + i , new away.net.URLRequest( url ) , false, null, true);
                }
                else
                {

                    data_len = this._newBlockBytes.readUnsignedInt();
                    var data    : away.utils.ByteArray;
                        data = new away.utils.ByteArray();

                    this._newBlockBytes.readBytes(data, 0, data_len);
                    this._pAddDependency(  this._cur_block_id.toString() + &quot;#&quot; + i , null, false, data , true);
                }
            }

            // Ignore for now
            this.parseProperties(null);
            this._blocks[blockID].extras = this.parseUserAttributes();
            this._pPauseAndRetrieveDependencies();
            this._blocks[blockID].data = asset;

            if (this._debug)
            {
                var textureStylesNames:Array = [&quot;external&quot;, &quot;embed&quot;]
                console.log(&quot;Start parsing 6 &quot; + textureStylesNames[type] + &quot; Bitmaps for CubeTexture&quot;);
            }
        }

        //Block ID = 91
        private parseSharedMethodBlock(blockID : number):void
        {
            var asset:away.materials.EffectMethodBase;

            this._blocks[blockID].name = this.parseVarStr();
            asset = this.parseSharedMethodList(blockID);
            this.parseUserAttributes();
            this._blocks[blockID].data = asset;
            this._pFinalizeAsset( &lt;away.library.IAsset&gt; asset, this._blocks[blockID].name);
            this._blocks[blockID].data = asset;

            if (this._debug)
            {
                console.log(&quot;Parsed a EffectMethod: Name = &quot; + asset.name + &quot; Type = &quot; + asset);
            }
        }
        //Block ID = 92
        private parseShadowMethodBlock(blockID : number ):void
        {
            var type            : number;
            var data_len        : number;
            var asset           : away.materials.ShadowMapMethodBase;
            var shadowLightID   : number;
            this._blocks[blockID].name = this.parseVarStr();

            shadowLightID = this._newBlockBytes.readUnsignedInt();
            var returnedArray:Array&lt;any&gt; = this.getAssetByID(shadowLightID, [away.library.AssetType.LIGHT]);

            if (!returnedArray[0])
            {
                this._blocks[blockID].addError(&quot;Could not find the TargetLight (ID = &quot; + shadowLightID + &quot; ) for this ShadowMethod - ShadowMethod not created&quot;);
                return;
            }

            asset = this.parseShadowMethodList(&lt;away.lights.LightBase&gt; returnedArray[1] , blockID);

            if (!asset)
                return;

            this.parseUserAttributes(); // Ignore for now
            this._pFinalizeAsset( &lt;away.library.IAsset&gt; asset, this._blocks[blockID].name);
            this._blocks[blockID].data = asset;

            if (this._debug)
            {
                console.log(&quot;Parsed a ShadowMapMethodMethod: Name = &quot; + asset.name + &quot; | Type = &quot; + asset + &quot; | Light-Name = &quot; , ( &lt;away.lights.LightBase&gt; returnedArray[1] ).name );
            }
        }


        //Block ID = 253
        private parseCommand(blockID: number):void
        {
            var hasBlocks       : boolean               = ( this._newBlockBytes.readUnsignedByte() == 1 );
            var par_id          : number                = this._newBlockBytes.readUnsignedInt();
            var mtx             : away.geom.Matrix3D    = this.parseMatrix3D();
            var name            : string                = this.parseVarStr();

            var parentObject    : away.containers.ObjectContainer3D;
            var targetObject    : away.containers.ObjectContainer3D;

            var returnedArray:Array&lt;any&gt; = this.getAssetByID(par_id, [away.library.AssetType.CONTAINER, away.library.AssetType.LIGHT, away.library.AssetType.MESH, away.library.AssetType.ENTITY, away.library.AssetType.SEGMENT_SET]);

            if (returnedArray[0])
            {
                parentObject = &lt;away.containers.ObjectContainer3D&gt; returnedArray[1];
            }

            var numCommands     : number = this._newBlockBytes.readShort();
            var typeCommand     : number = this._newBlockBytes.readShort();

            var props           : AWDProperties = this.parseProperties({1:AWDParser.BADDR});

            switch (typeCommand)
            {
                case 1:

                    var targetID : number = props.get(1, 0);
                    var returnedArrayTarget:Array&lt;any&gt; = this.getAssetByID(targetID, [away.library.AssetType.LIGHT, away.library.AssetType.TEXTURE_PROJECTOR]); //for no only light is requested!!!!

                    if ((!returnedArrayTarget[0]) &amp;&amp; (targetID != 0))
                    {
                        this._blocks[blockID].addError(&quot;Could not find the light (ID = &quot; + targetID + &quot; ( for this CommandBock!&quot;);
                        return;
                    }

                    targetObject = returnedArrayTarget[1];

                    if (parentObject)
                    {
                        parentObject.addChild(targetObject);
                    }

                    targetObject.transform = mtx;

                    break;
            }

            if (targetObject)
            {
                props = this.parseProperties({1:this._matrixNrType, 2:this._matrixNrType, 3:this._matrixNrType, 4:AWDParser.UINT8});

                targetObject.pivotPoint = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                targetObject.extra = this.parseUserAttributes();

            }
            this._blocks[blockID].data = targetObject

            if (this._debug)
            {
                console.log(&quot;Parsed a CommandBlock: Name = &#x27;&quot; + name);
            }

        }

        //blockID 255
        private parseMetaData(blockID:number):void
        {
            var props:AWDProperties = this.parseProperties({1:AWDParser.UINT32, 2:AWDParser.AWDSTRING, 3:AWDParser.AWDSTRING, 4:AWDParser.AWDSTRING, 5:AWDParser.AWDSTRING});

            if (this._debug)
            {
                console.log(&quot;Parsed a MetaDataBlock: TimeStamp         = &quot; + props.get(1, 0));
                console.log(&quot;                        EncoderName       = &quot; + props.get(2, &quot;unknown&quot;));
                console.log(&quot;                        EncoderVersion    = &quot; + props.get(3, &quot;unknown&quot;));
                console.log(&quot;                        GeneratorName     = &quot; + props.get(4, &quot;unknown&quot;));
                console.log(&quot;                        GeneratorVersion  = &quot; + props.get(5, &quot;unknown&quot;));
            }
        }
        //blockID 254
        private parseNameSpace(blockID:number):void
        {
            var id:number               = this._newBlockBytes.readUnsignedByte();
            var nameSpaceString:string  = this.parseVarStr();
            if (this._debug)
                console.log(&quot;Parsed a NameSpaceBlock: ID = &quot; + id + &quot; | String = &quot; + nameSpaceString);
        }

        //--Parser UTILS---------------------------------------------------------------------------

        // this functions reads and creates a ShadowMethodMethod
        private parseShadowMethodList(light:away.lights.LightBase, blockID:number):away.materials.ShadowMapMethodBase
        {

            var methodType      : number = this._newBlockBytes.readUnsignedShort();
            var shadowMethod    : away.materials.ShadowMapMethodBase;
            var props           : AWDProperties = this.parseProperties({1:AWDParser.BADDR, 2:AWDParser.BADDR, 3:AWDParser.BADDR, 101:this._propsNrType, 102:this._propsNrType, 103:this._propsNrType, 201:AWDParser.UINT32, 202:AWDParser.UINT32, 301:AWDParser.UINT16, 302:AWDParser.UINT16, 401:AWDParser.UINT8, 402:AWDParser.UINT8, 601:AWDParser.COLOR, 602:AWDParser.COLOR, 701:AWDParser.BOOL, 702:AWDParser.BOOL, 801:AWDParser.MTX4x4});

            var targetID        : number;
            var returnedArray   : Array
            switch (methodType)
            {
    //				case 1001: //CascadeShadowMapMethod
    //					targetID = props.get(1, 0);
    //					returnedArray = getAssetByID(targetID, [AssetType.SHADOW_MAP_METHOD]);
    //					if (!returnedArray[0]) {
    //						_blocks[blockID].addError(&quot;Could not find the ShadowBaseMethod (ID = &quot; + targetID + &quot; ) for this CascadeShadowMapMethod - ShadowMethod not created&quot;);
    //						return shadowMethod;
    //					}
    //					shadowMethod = new CascadeShadowMapMethod(returnedArray[1]);
    //					break;
    //				case 1002: //NearShadowMapMethod
    //					targetID = props.get(1, 0);
    //					returnedArray = getAssetByID(targetID, [AssetType.SHADOW_MAP_METHOD]);
    //					if (!returnedArray[0]) {
    //						_blocks[blockID].addError(&quot;Could not find the ShadowBaseMethod (ID = &quot; + targetID + &quot; ) for this NearShadowMapMethod - ShadowMethod not created&quot;);
    //						return shadowMethod;
    //					}
    //					shadowMethod = new NearShadowMapMethod(returnedArray[1]);
    //					break;
    //				case 1101: //FilteredShadowMapMethod
    //					shadowMethod = new FilteredShadowMapMethod(DirectionalLight(light));
    //					FilteredShadowMapMethod(shadowMethod).alpha = props.get(101, 1);
    //					FilteredShadowMapMethod(shadowMethod).epsilon = props.get(102, 0.002);
    //					break;
    //				case 1102: //DitheredShadowMapMethod
    //					shadowMethod = new DitheredShadowMapMethod(DirectionalLight(light), props.get(201, 5));
    //					DitheredShadowMapMethod(shadowMethod).alpha = props.get(101, 1);
    //					DitheredShadowMapMethod(shadowMethod).epsilon = props.get(102, 0.002);
    //					DitheredShadowMapMethod(shadowMethod).range = props.get(103, 1);
    //					break;
    //				case 1103: //SoftShadowMapMethod
    //					shadowMethod = new SoftShadowMapMethod(DirectionalLight(light), props.get(201, 5));
    //					SoftShadowMapMethod(shadowMethod).alpha = props.get(101, 1);
    //					SoftShadowMapMethod(shadowMethod).epsilon = props.get(102, 0.002);
    //					SoftShadowMapMethod(shadowMethod).range = props.get(103, 1);
    //					break;
    //				case 1104: //HardShadowMapMethod
    //					shadowMethod = new HardShadowMapMethod(light);
    //					HardShadowMapMethod(shadowMethod).alpha = props.get(101, 1);
    //					HardShadowMapMethod(shadowMethod).epsilon = props.get(102, 0.002);
    //					break;

            }
            this.parseUserAttributes();
            return shadowMethod;
        }

        // this functions reads and creates a EffectMethod
        private parseSharedMethodList(blockID : number):away.materials.EffectMethodBase
        {

            var methodType          : number = this._newBlockBytes.readUnsignedShort();
            var effectMethodReturn  : away.materials.EffectMethodBase;

            var props               : AWDProperties = this.parseProperties({1:AWDParser.BADDR, 2:AWDParser.BADDR, 3:AWDParser.BADDR, 101:this._propsNrType, 102:this._propsNrType, 103:this._propsNrType, 104:this._propsNrType, 105:this._propsNrType, 106:this._propsNrType, 107:this._propsNrType, 201:AWDParser.UINT32, 202:AWDParser.UINT32, 301:AWDParser.UINT16, 302:AWDParser.UINT16, 401:AWDParser.UINT8, 402:AWDParser.UINT8, 601:AWDParser.COLOR, 602:AWDParser.COLOR, 701:AWDParser.BOOL, 702:AWDParser.BOOL});
            var targetID            : number;
            var returnedArray       : Array;
            switch (methodType) {
                // Effect Methods
    //				case 401: //ColorMatrix
    //					effectMethodReturn = new ColorMatrixMethod(props.get(101, new Array(0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)));
    //					break;
    //				case 402: //ColorTransform
    //					effectMethodReturn = new ColorTransformMethod();
    //					var offCol:uint = props.get(601, 0x00000000);
    //					var newColorTransform:ColorTransform = new ColorTransform(props.get(102, 1), props.get(103, 1), props.get(104, 1), props.get(101, 1), ((offCol &gt;&gt; 16) &amp; 0xFF), ((offCol &gt;&gt; 8) &amp; 0xFF), (offCol &amp; 0xFF), ((offCol &gt;&gt; 24) &amp; 0xFF));
    //					ColorTransformMethod(effectMethodReturn).colorTransform = newColorTransform;
    //					break;
    //				case 403: //EnvMap
    //					targetID = props.get(1, 0);
    //					returnedArray = getAssetByID(targetID, [AssetType.TEXTURE], &quot;CubeTexture&quot;);
    //					if (!returnedArray[0])
    //						_blocks[blockID].addError(&quot;Could not find the EnvMap (ID = &quot; + targetID + &quot; ) for this EnvMapMethod&quot;);
    //					effectMethodReturn = new EnvMapMethod(returnedArray[1], props.get(101, 1));
    //					targetID = props.get(2, 0);
    //					if (targetID &gt; 0) {
    //						returnedArray = getAssetByID(targetID, [AssetType.TEXTURE]);
    //						if (!returnedArray[0])
    //							_blocks[blockID].addError(&quot;Could not find the Mask-texture (ID = &quot; + targetID + &quot; ) for this EnvMapMethod&quot;);
    //						EnvMapMethod(effectMethodReturn).mask = returnedArray[1];
    //					}
    //					break;
    //				case 404: //LightMapMethod
    //					targetID = props.get(1, 0);
    //					returnedArray = getAssetByID(targetID, [AssetType.TEXTURE]);
    //					if (!returnedArray[0])
    //						_blocks[blockID].addError(&quot;Could not find the LightMap (ID = &quot; + targetID + &quot; ) for this LightMapMethod&quot;);
    //					effectMethodReturn = new LightMapMethod(returnedArray[1], blendModeDic[props.get(401, 10)]); //usesecondaryUV not set
    //					break;
    //				case 405: //ProjectiveTextureMethod
    //					targetID = props.get(1, 0);
    //					returnedArray = getAssetByID(targetID, [AssetType.TEXTURE_PROJECTOR]);
    //					if (!returnedArray[0])
    //						_blocks[blockID].addError(&quot;Could not find the TextureProjector (ID = &quot; + targetID + &quot; ) for this ProjectiveTextureMethod&quot;);
    //					effectMethodReturn = new ProjectiveTextureMethod(returnedArray[1], blendModeDic[props.get(401, 10)]);
    //					break;
    //				case 406: //RimLightMethod
    //					effectMethodReturn = new RimLightMethod(props.get(601, 0xffffff), props.get(101, 0.4), props.get(101, 2)); //blendMode
    //					break;
    //				case 407: //AlphaMaskMethod
    //					targetID = props.get(1, 0);
    //					returnedArray = getAssetByID(targetID, [AssetType.TEXTURE]);
    //					if (!returnedArray[0])
    //						_blocks[blockID].addError(&quot;Could not find the Alpha-texture (ID = &quot; + targetID + &quot; ) for this AlphaMaskMethod&quot;);
    //					effectMethodReturn = new AlphaMaskMethod(returnedArray[1], props.get(701, false));
    //					break;
    //				case 408: //RefractionEnvMapMethod
    //					targetID = props.get(1, 0);
    //					returnedArray = getAssetByID(targetID, [AssetType.TEXTURE], &quot;CubeTexture&quot;);
    //					if (!returnedArray[0])
    //						_blocks[blockID].addError(&quot;Could not find the EnvMap (ID = &quot; + targetID + &quot; ) for this RefractionEnvMapMethod&quot;);
    //					effectMethodReturn = new RefractionEnvMapMethod(returnedArray[1], props.get(101, 0.1), props.get(102, 0.01), props.get(103, 0.01), props.get(104, 0.01));
    //					RefractionEnvMapMethod(effectMethodReturn).alpha = props.get(104, 1);
    //					break;
    //				case 409: //OutlineMethod
    //					effectMethodReturn = new OutlineMethod(props.get(601, 0x00000000), props.get(101, 1), props.get(701, true), props.get(702, false));
    //					break;
    //				case 410: //FresnelEnvMapMethod
    //					targetID = props.get(1, 0);
    //					returnedArray = getAssetByID(targetID, [AssetType.TEXTURE], &quot;CubeTexture&quot;);
    //					if (!returnedArray[0])
    //						_blocks[blockID].addError(&quot;Could not find the EnvMap (ID = &quot; + targetID + &quot; ) for this FresnelEnvMapMethod&quot;);
    //					effectMethodReturn = new FresnelEnvMapMethod(returnedArray[1], props.get(101, 1));
    //					break;
    //				case 411: //FogMethod
    //					effectMethodReturn = new FogMethod(props.get(101, 0), props.get(102, 1000), props.get(601, 0x808080));
    //					break;

            }
            this.parseUserAttributes();
            return effectMethodReturn;

        }

        private parseUserAttributes():Object
        {
            var attributes  :Object;
            var list_len    :number;
            var attibuteCnt :number;

            list_len = this._newBlockBytes.readUnsignedInt();

            if (list_len &gt; 0)
            {

                var list_end:number;

                attributes = {};

                list_end = this._newBlockBytes.position + list_len;

                while (this._newBlockBytes.position &lt; list_end)
                {
                    var ns_id:number;
                    var attr_key:string;
                    var attr_type:number;
                    var attr_len:number;
                    var attr_val:any;

                    // TODO: Properly tend to namespaces in attributes
                    ns_id       = this._newBlockBytes.readUnsignedByte();
                    attr_key    = this.parseVarStr();
                    attr_type   = this._newBlockBytes.readUnsignedByte();
                    attr_len    = this._newBlockBytes.readUnsignedInt();

                    if ((this._newBlockBytes.position + attr_len) &gt; list_end)
                    {
                        console.log(&quot;           Error in reading attribute # &quot; + attibuteCnt + &quot; = skipped to end of attribute-list&quot;);
                        this._newBlockBytes.position = list_end;
                        return attributes;
                    }

                    switch (attr_type)
                    {
                        case AWDParser.AWDSTRING:
                            attr_val = this._newBlockBytes.readUTFBytes(attr_len);
                            break;
                        case AWDParser.INT8:
                            attr_val = this._newBlockBytes.readByte();
                            break;
                        case AWDParser.INT16:
                            attr_val = this._newBlockBytes.readShort();
                            break;
                        case AWDParser.INT32:
                            attr_val = this._newBlockBytes.readInt();
                            break;
                        case AWDParser.BOOL:
                        case AWDParser.UINT8:
                            attr_val = this._newBlockBytes.readUnsignedByte();
                            break;
                        case AWDParser.UINT16:
                            attr_val = this._newBlockBytes.readUnsignedShort();
                            break;
                        case AWDParser.UINT32:
                        case AWDParser.BADDR:
                            attr_val = this._newBlockBytes.readUnsignedInt();
                            break;
                        case AWDParser.FLOAT32:
                            attr_val = this._newBlockBytes.readFloat();
                            break;
                        case AWDParser.FLOAT64:
                            attr_val = this._newBlockBytes.readDouble();
                            break;
                        default:
                            attr_val = &#x27;unimplemented attribute type &#x27; + attr_type;
                            this._newBlockBytes.position += attr_len;
                            break;
                    }

                    if (this._debug)
                    {
                        console.log(&quot;attribute = name: &quot; + attr_key + &quot;  / value = &quot; + attr_val);
                    }

                    attributes[attr_key] = attr_val;
                    attibuteCnt += 1;
                }
            }

            return attributes;
        }

        private parseProperties(expected:Object):AWDProperties
        {
            var list_end:number;
            var list_len:number;
            var propertyCnt:number= 0;
            var props:AWDProperties = new AWDProperties();

            list_len = this._newBlockBytes.readUnsignedInt();
            list_end = this._newBlockBytes.position + list_len;

            if (expected)
            {

                while (this._newBlockBytes.position &lt; list_end)
                {
                    var len:number;
                    var key:number;
                    var type:number;

                    key = this._newBlockBytes.readUnsignedShort();
                    len = this._newBlockBytes.readUnsignedInt();

                    if ((this._newBlockBytes.position + len) &gt; list_end)
                    {
                        console.log(&quot;           Error in reading property # &quot; + propertyCnt + &quot; = skipped to end of propertie-list&quot;);
                        this._newBlockBytes.position = list_end;
                        return props;
                    }

                    if (expected.hasOwnProperty(key.toString()))
                    {
                        type = expected[key];
                        props.set(key, this.parseAttrValue(type, len));
                    }
                    else
                    {
                        this._newBlockBytes.position += len;
                    }

                    propertyCnt += 1;

                }
            }
            else
            {
                this._newBlockBytes.position = list_end;
            }

            return props;

        }

        private parseAttrValue(type:number, len:number):any
        {
            var elem_len:number;
            var read_func:Function;

            switch (type)
            {

                case AWDParser.BOOL:
                case AWDParser.INT8:
                    elem_len = 1;
                    read_func = this._newBlockBytes.readByte;
                    break;

                case AWDParser.INT16:
                    elem_len = 2;
                    read_func = this._newBlockBytes.readShort;
                    break;

                case AWDParser.INT32:
                    elem_len = 4;
                    read_func = this._newBlockBytes.readInt;
                    break;

                case AWDParser.UINT8:
                    elem_len = 1;
                    read_func = this._newBlockBytes.readUnsignedByte;
                    break;

                case AWDParser.UINT16:
                    elem_len = 2;
                    read_func = this._newBlockBytes.readUnsignedShort;
                    break;

                case AWDParser.UINT32:
                case AWDParser.COLOR:
                case AWDParser.BADDR:
                    elem_len = 4;
                    read_func = this._newBlockBytes.readUnsignedInt;
                    break;

                case AWDParser.FLOAT32:
                    elem_len = 4;
                    read_func = this._newBlockBytes.readFloat;
                    break;

                case AWDParser.FLOAT64:
                    elem_len = 8;
                    read_func = this._newBlockBytes.readDouble;
                    break;

                case AWDParser.AWDSTRING:
                    return this._newBlockBytes.readUTFBytes(len);

                case AWDParser.VECTOR2x1:
                case AWDParser.VECTOR3x1:
                case AWDParser.VECTOR4x1:
                case AWDParser.MTX3x2:
                case AWDParser.MTX3x3:
                case AWDParser.MTX4x3:
                case AWDParser.MTX4x4:
                    elem_len = 8;
                    read_func = this._newBlockBytes.readDouble;
                    break;

            }

            if (elem_len &lt; len)
            {
                var list      : Array&lt;any&gt;   = [];
                var num_read  : number       = 0;
                var num_elems : number       = len/elem_len;

                while (num_read &lt; num_elems)
                {
                    list.push( read_func.apply( this._newBlockBytes ) ); // list.push(read_func());
                    num_read++;
                }

                return list;
            }
            else
            {

                var val:any = read_func.apply( this._newBlockBytes );//read_func();
                return val;
            }
        }

        private parseHeader():void
        {
            var flags       : number;
            var body_len    : number;

            this._byteData.position = 3; // Skip magic string and parse version

            this._version[0] = this._byteData.readUnsignedByte();
            this._version[1] = this._byteData.readUnsignedByte();

            flags = this._byteData.readUnsignedShort(); // Parse bit flags

            this._streaming = bitFlags.test(flags, bitFlags.FLAG1);

            if ((this._version[0] == 2) &amp;&amp; (this._version[1] == 1))
            {
                this._accuracyMatrix = bitFlags.test(flags, bitFlags.FLAG2);
                this._accuracyGeo = bitFlags.test(flags, bitFlags.FLAG3);
                this._accuracyProps = bitFlags.test(flags, bitFlags.FLAG4);
            }

            // if we set _accuracyOnBlocks, the precision-values are read from each block-header.

            // set storagePrecision types
            this._geoNrType = AWDParser.FLOAT32;

            if (this._accuracyGeo)
            {
                this._geoNrType = AWDParser.FLOAT64;
            }

            this._matrixNrType = AWDParser.FLOAT32;

            if (this._accuracyMatrix)
            {
                this._matrixNrType = AWDParser.FLOAT64;
            }

            this._propsNrType = AWDParser.FLOAT32;

            if (this._accuracyProps)
            {
                this._propsNrType = AWDParser.FLOAT64;
            }

            this._compression = this._byteData.readUnsignedByte(); // compression

            if (this._debug)
            {
                console.log(&quot;Import AWDFile of version = &quot; + this._version[0] + &quot; - &quot; + this._version[1]);
                console.log(&quot;Global Settings = Compression = &quot; + this._compression + &quot; | Streaming = &quot; + this._streaming + &quot; | Matrix-Precision = &quot; + this._accuracyMatrix + &quot; | Geometry-Precision = &quot; + this._accuracyGeo + &quot; | Properties-Precision = &quot; + this._accuracyProps);
            }

            // Check file integrity
            body_len = this._byteData.readUnsignedInt();
            if (!this._streaming &amp;&amp; body_len != this._byteData.getBytesAvailable() )
            {
                this._pDieWithError(&#x27;AWD2 body length does not match header integrity field&#x27;);
            }

        }

        private parseVarStr():string
        {

            var len:number = this._newBlockBytes.readUnsignedShort();
            return this._newBlockBytes.readUTFBytes(len);
        }

        private getAssetByID(assetID:number, assetTypesToGet:Array&lt;string&gt;, extraTypeInfo:string = &quot;SingleTexture&quot;):Array&lt;any&gt;
        {
            var returnArray:Array&lt;any&gt; = new Array();
            var typeCnt:number = 0;
            if (assetID &gt; 0)
            {
                if (this._blocks[assetID])
                {
                    if (this._blocks[assetID].data)
                    {
                        while (typeCnt &lt; assetTypesToGet.length)
                        {

                            var iasset : away.library.IAsset = &lt;away.library.IAsset&gt; this._blocks[assetID].data;

                            if ( iasset.assetType == assetTypesToGet[typeCnt]) {
                                //if the right assetType was found
                                if ((assetTypesToGet[typeCnt] == away.library.AssetType.TEXTURE) &amp;&amp; (extraTypeInfo == &quot;CubeTexture&quot;))
                                {
                                    if (this._blocks[assetID].data instanceof away.textures.HTMLImageElementCubeTexture )
                                    {
                                        returnArray.push(true);
                                        returnArray.push(this._blocks[assetID].data);
                                        return returnArray;
                                    }
                                }
                                if ((assetTypesToGet[typeCnt] == away.library.AssetType.TEXTURE) &amp;&amp; (extraTypeInfo == &quot;SingleTexture&quot;))
                                {
                                    if (this._blocks[assetID].data instanceof away.textures.HTMLImageElementTexture )
                                    {
                                        returnArray.push(true);
                                        returnArray.push(this._blocks[assetID].data);
                                        return returnArray;
                                    }
                                } else {
                                    returnArray.push(true);
                                    returnArray.push(this._blocks[assetID].data);
                                    return returnArray;

                                }
                            }
                            //if ((assetTypesToGet[typeCnt] == away.library.AssetType.GEOMETRY) &amp;&amp; (IAsset(_blocks[assetID].data).assetType == AssetType.MESH)) {
                            if ((assetTypesToGet[typeCnt] == away.library.AssetType.GEOMETRY) &amp;&amp; (iasset.assetType == away.library.AssetType.MESH))
                            {

                                var mesh : away.entities.Mesh = &lt;away.entities.Mesh&gt; this._blocks[assetID].data

                                returnArray.push(true);
                                returnArray.push( mesh.geometry );
                                return returnArray;

                            }

                            typeCnt++;
                        }
                    }
                }
            }
            // if the function has not returned anything yet, the asset is not found, or the found asset is not the right type.
            returnArray.push(false);
            returnArray.push(this.getDefaultAsset(assetTypesToGet[0], extraTypeInfo));
            return returnArray;
        }

        private getDefaultAsset(assetType:string, extraTypeInfo:string):away.library.IAsset
        {
            switch (true)
            {

                case (assetType == away.library.AssetType.TEXTURE):

                    if (extraTypeInfo == &quot;CubeTexture&quot;)
                        return this.getDefaultCubeTexture();
                    if (extraTypeInfo == &quot;SingleTexture&quot;)
                        return this.getDefaultTexture();
                    break;

                case (assetType == away.library.AssetType.MATERIAL):

                    return this.getDefaultMaterial()
                    break;

                default:

                    break;
            }

            return null;

        }

        private getDefaultMaterial():away.library.IAsset
        {
            if (!this._defaultBitmapMaterial)
                this._defaultBitmapMaterial = away.materials.DefaultMaterialManager.getDefaultMaterial();
            return  &lt;away.library.IAsset&gt;  this._defaultBitmapMaterial;
        }

        private getDefaultTexture():away.library.IAsset
        {

            if (!this._defaultTexture)
            {
                this._defaultTexture = away.materials.DefaultMaterialManager.getDefaultTexture();
            }

            return &lt;away.library.IAsset&gt; this._defaultTexture;

        }

        private getDefaultCubeTexture():away.library.IAsset
        {
            if (!this._defaultCubeTexture)
            {

                var defaultBitmap:away.display.BitmapData = away.materials.DefaultMaterialManager.createCheckeredBitmapData();//this._defaultTexture.bitmapData;

                this._defaultCubeTexture = new away.textures.BitmapCubeTexture(defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap);
                this._defaultCubeTexture.name = &quot;defaultTexture&quot;;
            }

            return &lt;away.library.IAsset&gt; this._defaultCubeTexture;
        }

        private readNumber(precision:boolean = false):number
        {
            if (precision)
                return this._newBlockBytes.readDouble();
            return this._newBlockBytes.readFloat();

        }

        private parseMatrix3D():away.geom.Matrix3D
        {
            return new away.geom.Matrix3D(this.parseMatrix43RawData());
        }

        private parseMatrix32RawData():Array&lt;number&gt;
        {
            var i:number;
            var mtx_raw:Array&lt;number&gt; = new Array&lt;number&gt;(6);
            for (i = 0; i &lt; 6; i++)
            {
                mtx_raw[i] = this._newBlockBytes.readFloat();
            }

            return mtx_raw;
        }

        private parseMatrix43RawData():Array&lt;number&gt;
        {
            var mtx_raw:Array&lt;number&gt; = new Array&lt;number&gt;(16);

            mtx_raw[0] = this.readNumber(this._accuracyMatrix);
            mtx_raw[1] = this.readNumber(this._accuracyMatrix);
            mtx_raw[2] = this.readNumber(this._accuracyMatrix);
            mtx_raw[3] = 0.0;
            mtx_raw[4] = this.readNumber(this._accuracyMatrix);
            mtx_raw[5] = this.readNumber(this._accuracyMatrix);
            mtx_raw[6] = this.readNumber(this._accuracyMatrix);
            mtx_raw[7] = 0.0;
            mtx_raw[8] = this.readNumber(this._accuracyMatrix);
            mtx_raw[9] = this.readNumber(this._accuracyMatrix);
            mtx_raw[10] = this.readNumber(this._accuracyMatrix);
            mtx_raw[11] = 0.0;
            mtx_raw[12] = this.readNumber(this._accuracyMatrix);
            mtx_raw[13] = this.readNumber(this._accuracyMatrix);
            mtx_raw[14] = this.readNumber(this._accuracyMatrix);
            mtx_raw[15] = 1.0;

            //TODO: fix max exporter to remove NaN values in joint 0 inverse bind pose

            if (isNaN(mtx_raw[0]))
            {
                mtx_raw[0] = 1;
                mtx_raw[1] = 0;
                mtx_raw[2] = 0;
                mtx_raw[4] = 0;
                mtx_raw[5] = 1;
                mtx_raw[6] = 0;
                mtx_raw[8] = 0;
                mtx_raw[9] = 0;
                mtx_raw[10] = 1;
                mtx_raw[12] = 0;
                mtx_raw[13] = 0;
                mtx_raw[14] = 0;

            }

            return mtx_raw;
        }

    }

}

class AWDBlock
{
	public id:number;
	public name:string;
	public data:any;
	public len:any;
	public geoID:number;
	public extras:Object;
	public bytes:away.utils.ByteArray;
	public errorMessages:Array&lt;string&gt;;
	public uvsForVertexAnimation:Array&lt;Array&lt;number&gt;&gt;;

	constructor()
	{
	}

    public dispose()
    {

        this.id = null;
        this.bytes = null;
        this.errorMessages = null;
        this.uvsForVertexAnimation = null;

    }

	public addError(errorMsg:string):void
	{
		if (!this.errorMessages)
			this.errorMessages = new Array&lt;string&gt;();
		this.errorMessages.push(errorMsg);
	}
}

class bitFlags
{
	public static FLAG1:number = 1;
	public static FLAG2:number = 2;
	public static FLAG3:number = 4;
	public static FLAG4:number = 8;
	public static FLAG5:number = 16;
	public static FLAG6:number = 32;
	public static FLAG7:number = 64;
	public static FLAG8:number = 128;
	public static FLAG9:number = 256;
	public static FLAG10:number = 512;
	public static FLAG11:number = 1024;
	public static FLAG12:number = 2048;
	public static FLAG13:number = 4096;
	public static FLAG14:number = 8192;
	public static FLAG15:number = 16384;
	public static FLAG16:number = 32768;

	public static test(flags:number, testFlag:number):boolean
	{
		return (flags &amp; testFlag) == testFlag;
	}
}

class AWDProperties
{
	public set(key:number, value:any):void
	{
		this[ key.toString() ] = value;
	}

	public get(key:number, fallback:any):any
	{

        console.log ( &#x27;this.hasOwnProperty(key.toString());&#x27; , key , fallback , this.hasOwnProperty(key.toString()) );

		if ( this.hasOwnProperty(key.toString()))
        {
			return this[key.toString()];
        }
		else
        {
			return fallback;
        }
	}
}


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
